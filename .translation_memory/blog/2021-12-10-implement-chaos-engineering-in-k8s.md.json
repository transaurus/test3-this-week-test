{
  "source_file_path_relative_to_docusaurus_root": "blog/2021-12-10-implement-chaos-engineering-in-k8s.md",
  "source_file_content_hash": "ae13e1a4f80105f1621a2eb77d731ffca386b1bfcbe31124119923e2a7d4be3b",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\nslug: /implement-chaos-engineering-in-k8s\ntitle: 'Implementing Chaos Engineering in K8s: Chaos Mesh Principle Analysis and Control Plane Development'\nauthors: mayocream\nimage: /img/blog/implement-chaos-engineering-in-k8s.png\ntags: [Chaos Mesh, Chaos Engineering]\n---",
      "source_content_hash": "ffb4cf38d7d244336988683361eca0dac15df5aff9dfc4ad6c693666049221aa",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_58cfcc64"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "53eaf0e1",
      "source_content": "![Implementing Chaos Engineering in K8s](/img/blog/implement-chaos-engineering-in-k8s.png)",
      "source_content_hash": "4c78a17be7d6583f328714aa74fdbbd7decd429442df06605ce361ec246804ef",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![在 K8s 中實現混沌工程](/img/blog/implement-chaos-engineering-in-k8s.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8ac585fb",
      "source_content": "[Chaos Mesh](https://chaos-mesh.org/docs/) is an open-source, cloud-native Chaos Engineering platform built on Kubernetes (K8s) custom resource definitions (CRDs). Chaos Mesh can simulate various types of faults and has an enormous capability to orchestrate fault scenarios. You can use Chaos Mesh to conveniently simulate various abnormalities that might occur in development, testing, and production environments and find potential problems in the system.",
      "source_content_hash": "849e8cba0f0c43d2468211c55a0bbc13c3b4768b3b95e8b163a9f020029488cd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "[Chaos Mesh](https://chaos-mesh.org/docs/) 是一個基於 Kubernetes (K8s) 自訂資源定義 (CRD) 的開源雲原生混沌工程平台。Chaos Mesh 能模擬多種類型的故障，並具備強大的故障場景編排能力。您可以使用 Chaos Mesh 方便地模擬開發、測試和生產環境中可能出現的各種異常狀況，從而發現系統中的潛在問題。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3e6699f4",
      "source_content": "<!--truncate-->",
      "source_content_hash": "f5cded2aa7e288e395fe4f67f9dabda2281904b2f5358d07302b3aa8be0acdfa",
      "node_type": "comment",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_3e6699f4"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cf898102",
      "source_content": "In this article, I'll explore the practice of Chaos Engineering in Kubernetes clusters, discuss important Chaos Mesh features through analysis of its source code, and explain how to develop Chaos Mesh's control plane with code examples.",
      "source_content_hash": "0a17aac24b5ea7ca73860c41633007e668a1cd45b7319d3db06833f944de589a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "本文將探討在 Kubernetes 叢集中實踐混沌工程的方法，透過源碼分析解讀 Chaos Mesh 的重要特性，並以程式碼範例說明如何開發 Chaos Mesh 的控制平面。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "42ad8e83",
      "source_content": "If you're not familiar with Chaos Mesh, please review the [Chaos Mesh documentation](https://chaos-mesh.org/docs/#architecture-overview) to get a basic knowledge of Chaos Mesh's architecture.",
      "source_content_hash": "f24f02a91498395f95006172e32db89db15fa5eac2bb785647c823f7a58914f6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "如果您不熟悉 Chaos Mesh，請先參閱 [Chaos Mesh 文件](https://chaos-mesh.org/docs/#architecture-overview) 以掌握其架構基礎知識。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f6168993",
      "source_content": "For the test code in this article, see the [mayocream/chaos-mesh-controlpanel-demo](https://github.com/mayocream/chaos-mesh-controlpanel-demo) repository on GitHub.",
      "source_content_hash": "82683b3f6c1840e7151189286fb3aff5b54cacf0d7e405c2ba82f8483e560d89",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "本文的測試程式碼請參閱 GitHub 上的 [mayocream/chaos-mesh-controlpanel-demo](https://github.com/mayocream/chaos-mesh-controlpanel-demo) 儲存庫。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "418617bd",
      "source_content": "## How Chaos Mesh creates chaos",
      "source_content_hash": "be08c013ab87f284b3bb2c017f4677d7477f634260e257efed6df4bc01d63b0b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## Chaos Mesh 如何製造混沌"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2fdadb08",
      "source_content": "Chaos Mesh is a Swiss army knife for implementing Chaos Engineering on Kubernetes. This section introduces how it works.",
      "source_content_hash": "e78701f7e79d05ae8aa3f3f76f1f65f0d119ccf83ab04917a057aa7c07b70ab4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 是在 Kubernetes 上實施混沌工程的瑞士軍刀。本節將介紹其運作原理。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ed7dde9c",
      "source_content": "### Privileged mode",
      "source_content_hash": "ec7bc259662e4dc003a5e0e69de4ba3fae62805d490e9409a37aac2aebfda9b9",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 特權模式"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a76548f8",
      "source_content": "Chaos Mesh runs privileged containers in Kubernetes to create failures. Chaos Daemon's Pod runs as `DaemonSet` and adds additional [capabilities](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities) to the Pod's container runtime via the Pod's security context.",
      "source_content_hash": "0457d066f8bec94acb32c96f086a70c21f31c64ebd4ddedf13a3d27baf66d82d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 透過在 Kubernetes 中運行特權容器來製造故障。Chaos Daemon 的 Pod 以 `DaemonSet` 形式運行，並透過 Pod 的安全上下文為容器運行時附加額外的 [權能](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "0c911872",
      "source_content": "```yaml\napiVersion: apps/v1\nkind: DaemonSet\nspec:\n template:\n   metadata: ...\n   spec:\n     containers:\n       - name: chaos-daemon\n         securityContext:\n           {{- if .Values.chaosDaemon.privileged }}\n           privileged: true\n           capabilities:\n             add:\n               - SYS_PTRACE\n           {{- else }}\n           capabilities:\n             add:\n               - SYS_PTRACE\n               - NET_ADMIN\n               - MKNOD\n               - SYS_CHROOT\n               - SYS_ADMIN\n               - KILL\n               # CAP_IPC_LOCK is used to lock memory\n               - IPC_LOCK\n           {{- end }}\n```",
      "source_content_hash": "2cdc696bd2be1ea07087ad1f038ea6e5e13b3df4aa8d733a1f198a26c23c3e52",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_0c911872"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e536ea0d",
      "source_content": "The Linux capabilities grant containers privileges to create and access the `/dev/fuse` Filesystem in Userspace (FUSE) pipe. FUSE is the Linux userspace filesystem interface. It lets non-privileged users create their own file systems without editing the kernel code.",
      "source_content_hash": "8064f6020422976357f3e8290c43eb82fd54cb7489c78b739e446c9fee8360b5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Linux 權能授予容器創建和訪問 `/dev/fuse` 用戶空間檔案系統 (FUSE) 管道的特權。FUSE 是 Linux 用戶空間檔案系統介面，它允許非特權用戶無需修改核心程式碼即可創建自己的檔案系統。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "40158b4b",
      "source_content": "According to [pull request #1109](https://github.com/chaos-mesh/chaos-mesh/pull/1109) on GitHub, the `DaemonSet` program uses cgo to call the Linux `makedev` function to create a FUSE pipe.",
      "source_content_hash": "c024b7c17b157dacdf8f62f7d1454f4cdb9705f31b192472b39da290aa859f9e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "根據 GitHub 上的 [pull request #1109](https://github.com/chaos-mesh/pull/1109)，`DaemonSet` 程式使用 cgo 調用 Linux `makedev` 函數來創建 FUSE 管道。",
          "reason": "URL for a 'link' was changed from 'https://github.com/chaos-mesh/chaos-mesh/pull/1109' to 'https://github.com/chaos-mesh/pull/1109'.",
          "timestamp": "2025-07-04T06:49:59.315831+00:00"
        }
      }
    },
    {
      "segment_id": "3adc0ceb",
      "source_content": "```go\n// #include <sys/sysmacros.h>\n// #include <sys/types.h>\n// // makedev is a macro, so a wrapper is needed\n// dev_t Makedev(unsigned int maj, unsigned int min) {\n//   return makedev(maj, min);\n// }\n// EnsureFuseDev ensures /dev/fuse exists. If not, it will create one\n\nfunc EnsureFuseDev() {\n   if _, err := os.Open(\"/dev/fuse\"); os.IsNotExist(err) {\n       // 10, 229 according to https://www.kernel.org/doc/Documentation/admin-guide/devices.txt\n       fuse := C.Makedev(10, 229)\n       syscall.Mknod(\"/dev/fuse\", 0o666|syscall.S_IFCHR, int(fuse))\n   }\n}\n```",
      "source_content_hash": "35d795dd08e3d09acfb34f709998152dde0c0a857461f0f80364ac6eda6c250a",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_3adc0ceb"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7736989b",
      "source_content": "In [pull request #1453](https://github.com/chaos-mesh/chaos-mesh/pull/1453), Chaos Daemon enables privileged mode by default; that is, it sets `privileged: true` in the container's `SecurityContext`.",
      "source_content_hash": "13b2cb088a1d27048ef7a1a3eda7bb523c1fe8535ba16c2e15465e6aa083b3b7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "在 [pull request #1453](https://github.com/chaos-mesh/pull/1453) 中，Chaos Daemon 預設啟用特權模式，即在容器的 `SecurityContext` 中設置 `privileged: true`。",
          "reason": "URL for a 'link' was changed from 'https://github.com/chaos-mesh/chaos-mesh/pull/1453' to 'https://github.com/chaos-mesh/pull/1453'.",
          "timestamp": "2025-07-04T06:49:59.315862+00:00"
        }
      }
    },
    {
      "segment_id": "8a9b6c26",
      "source_content": "### Killing Pods",
      "source_content_hash": "9650e900c10b6e388917ef87ad66c4da23207c7982b7c93be6c0503f71d2e0ce",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 終止 Pod"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a1fa5396",
      "source_content": "`PodKill`, `PodFailure`, and `ContainerKill` belong to the `PodChaos` category. `PodKill` randomly kills a Pod. It calls the API server to send the kill command.",
      "source_content_hash": "a911e538c0d5a6024b44fe74b7001c6013926198d675da968b39ec803cbfe47a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`PodKill`、`PodFailure` 和 `ContainerKill` 屬於 `PodChaos` 類別。`PodKill` 會隨機終止 Pod，它透過調用 API 伺服器發送終止指令。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8c3563d3",
      "source_content": "```go\nimport (\n   \"context\"\n   v1 \"k8s.io/api/core/v1\"\n   \"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\ntype Impl struct {\n   client.Client\n}\n\nfunc (impl *Impl) Apply(ctx context.Context, index int, records []*v1alpha1.Record, obj v1alpha1.InnerObject) (v1alpha1.Phase, error) {\n   ...\n   err = impl.Get(ctx, namespacedName, &pod)\n   if err != nil {\n       // TODO: handle this error\n       return v1alpha1.NotInjected, err\n   }\n   err = impl.Delete(ctx, &pod, &client.DeleteOptions{\n       GracePeriodSeconds: &podchaos.Spec.GracePeriod, // PeriodSeconds has to be set specifically\n   })\n   ...\n   return v1alpha1.Injected, nil\n}\n```",
      "source_content_hash": "a6d31ce49af2c82114aee32ceb58fe02d4efa9f8b5894f6e7905388b81241874",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_8c3563d3"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "0801d969",
      "source_content": "The `GracePeriodSeconds` parameter lets Kubernetes [forcibly terminate a Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced). For example, if you need to delete a Pod immediately, use the `kubectl delete pod --grace-period=0 --force` command.",
      "source_content_hash": "c73c37ed4820909f41e11d24673cc47fe409861fe13c7177ec766943e0a911b5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`GracePeriodSeconds` 參數允許 Kubernetes [強制終止 Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced)。例如若需立即刪除 Pod，可使用 `kubectl delete pod --grace-period=0 --force` 指令。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3c19e221",
      "source_content": "`PodFailure` patches the Pod object resource to replace the image in the Pod with a wrong one. Chaos only modifies the `image` fields of `containers` and `initContainers`. This is because most of the metadata about a Pod is immutable. For more details, see [Pod update and replacement](https://kubernetes.io/docs/concepts/workloads/pods/#pod-update-and-replacement).",
      "source_content_hash": "f85e5161fbcc0f6cf9062d3a2a7418735fd421c9b528668e7e79c190261648ce",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "`PodFailure` 會修補 Pod 物件資源，將 Pod 中的鏡像替換為錯誤版本。混沌操作僅修改 `containers` 和 `initContainers` 的 `image` 欄位，這是因為 Pod 的大多數元數據不可變。詳情請參閱 [Pod 更新與替換](https://kubernetes.io/docs/concepts/workloads/pods/#pod-update-and-replacement)。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`image`', Translation: '`containers`'.",
          "timestamp": "2025-07-04T06:49:59.315888+00:00"
        }
      }
    },
    {
      "segment_id": "f155ef1e",
      "source_content": "```go\nfunc (impl *Impl) Apply(ctx context.Context, index int, records []*v1alpha1.Record, obj v1alpha1.InnerObject) (v1alpha1.Phase, error) {\n   ...\n   pod := origin.DeepCopy()\n   for index := range pod.Spec.Containers {\n       originImage := pod.Spec.Containers[index].Image\n       name := pod.Spec.Containers[index].Name\n       key := annotation.GenKeyForImage(podchaos, name, false)\n       if pod.Annotations == nil {\n           pod.Annotations = make(map[string]string)\n       }\n       // If the annotation is already existed, we could skip the reconcile for this container\n       if _, ok := pod.Annotations[key]; ok {\n           continue\n       }\n       pod.Annotations[key] = originImage\n       pod.Spec.Containers[index].Image = config.ControllerCfg.PodFailurePauseImage\n   }\n   for index := range pod.Spec.InitContainers {\n       originImage := pod.Spec.InitContainers[index].Image\n       name := pod.Spec.InitContainers[index].Name\n       key := annotation.GenKeyForImage(podchaos, name, true)\n       if pod.Annotations == nil {\n           pod.Annotations = make(map[string]string)\n       }\n       // If the annotation is already existed, we could skip the reconcile for this container\n       if _, ok := pod.Annotations[key]; ok {\n           continue\n       }\n       pod.Annotations[key] = originImage\n       pod.Spec.InitContainers[index].Image = config.ControllerCfg.PodFailurePauseImage\n   }\n   err = impl.Patch(ctx, pod, client.MergeFrom(&origin))\n   if err != nil {\n       // TODO: handle this error\n       return v1alpha1.NotInjected, err\n   }\n   return v1alpha1.Injected, nil\n}\n```",
      "source_content_hash": "ea8fe9c66aa5fc2f132a6528a17e1a946267c6d24e7f7c571247a4c9abb115ab",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f155ef1e"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "63565425",
      "source_content": "The default container image that causes failures is `gcr.io/google-containers/pause:latest`.",
      "source_content_hash": "e0cb31b572567ec072479496cbc688b50a271ff1fb3f3b3e674d1c048bb24ff4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "預設導致故障的容器鏡像為 `gcr.io/google-containers/pause:latest`。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1496ef51",
      "source_content": "`PodKill` and `PodFailure` control the Pod lifecycle through the Kubernetes API server. But `ContainerKill` does this through Chaos Daemon that runs on the cluster node. `ContainerKill` uses Chaos Controller Manager to run the client to initiate gRPC calls to Chaos Daemon.",
      "source_content_hash": "bdc4416d18f525e1997615527f37abe3ccf985f8ec97ba8d99708e75f9c9e787",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`PodKill` 和 `PodFailure` 透過 Kubernetes API 伺服器控制 Pod 生命週期，但 `ContainerKill` 則是透過運行在叢集節點上的 Chaos Daemon 實現。`ContainerKill` 使用 Chaos Controller Manager 運行客戶端，向 Chaos Daemon 發起 gRPC 調用。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b68d496b",
      "source_content": "```go\nfunc (b *ChaosDaemonClientBuilder) Build(ctx context.Context, pod *v1.Pod) (chaosdaemonclient.ChaosDaemonClientInterface, error) {\n   ...\n   daemonIP, err := b.FindDaemonIP(ctx, pod)\n   if err != nil {\n       return nil, err\n   }\n   builder := grpcUtils.Builder(daemonIP, config.ControllerCfg.ChaosDaemonPort).WithDefaultTimeout()\n   if config.ControllerCfg.TLSConfig.ChaosMeshCACert != \"\" {\n       builder.TLSFromFile(config.ControllerCfg.TLSConfig.ChaosMeshCACert, config.ControllerCfg.TLSConfig.ChaosDaemonClientCert, config.ControllerCfg.TLSConfig.ChaosDaemonClientKey)\n   } else {\n       builder.Insecure()\n   }\n   cc, err := builder.Build()\n   if err != nil {\n       return nil, err\n   }\n   return chaosdaemonclient.New(cc), nil\n}\n```",
      "source_content_hash": "5c7c88d59f634ed798ba5f85f29f1890d099add0a9b06fe77ec764b6dac8870c",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_b68d496b"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9ef42155",
      "source_content": "When Chaos Controller Manager sends commands to Chaos Daemon, it creates a corresponding client based on the Pod information. For example, to control a Pod on a node, it creates a client by getting the `ClusterIP` of the node where the Pod is located. If the Transport Layer Security (TLS) certificate configuration exists, Controller Manager adds the TLS certificate for the client.",
      "source_content_hash": "18e9d14543b6ba6b6f743b7cdbbeddf70070f410330cb5c836880fe634e149ca",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "當 Chaos Controller Manager 向 Chaos Daemon 發送指令時，它會根據 Pod 的資訊建立對應的客戶端。例如，為了控制節點上的 Pod，會透過獲取該 Pod 所在節點的 `ClusterIP` 來建立客戶端。若存在傳輸層安全性 (TLS) 憑證配置，Controller Manager 會為客戶端新增 TLS 憑證。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "fe25bd72",
      "source_content": "When Chaos Daemon starts, if it has a TLS certificate it attaches the certificate to enable gRPCS. The TLS configuration option `RequireAndVerifyClientCert` indicates whether to enable mutual TLS (mTLS) authentication.",
      "source_content_hash": "d58a6618e0d89ae1ce8aad2e578679a0e11aff577861d7f0498c9729dac30c4b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "當 Chaos Daemon 啟動時，若具備 TLS 憑證，會附加該憑證以啟用 gRPCS。TLS 配置選項 `RequireAndVerifyClientCert` 表示是否啟用雙向 TLS (mTLS) 驗證。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "65ba7468",
      "source_content": "```go\nfunc newGRPCServer(containerRuntime string, reg prometheus.Registerer, tlsConf tlsConfig) (*grpc.Server, error) {\n   ...\n   if tlsConf != (tlsConfig{}) {\n       caCert, err := ioutil.ReadFile(tlsConf.CaCert)\n       if err != nil {\n           return nil, err\n       }\n       caCertPool := x509.NewCertPool()\n       caCertPool.AppendCertsFromPEM(caCert)\n       serverCert, err := tls.LoadX509KeyPair(tlsConf.Cert, tlsConf.Key)\n       if err != nil {\n           return nil, err\n       }\n       creds := credentials.NewTLS(&tls.Config{\n           Certificates: []tls.Certificate{serverCert},\n           ClientCAs:    caCertPool,\n           ClientAuth:   tls.RequireAndVerifyClientCert,\n       })\n       grpcOpts = append(grpcOpts, grpc.Creds(creds))\n   }\n   s := grpc.NewServer(grpcOpts...)\n   grpcMetrics.InitializeMetrics(s)\n   pb.RegisterChaosDaemonServer(s, ds)\n   reflection.Register(s)\n   return s, nil\n}\n```",
      "source_content_hash": "721a3652e6d43bd4ab3bcb1be02c1dc5f2d7218b302a7e4e92d078530826ed98",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_65ba7468"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "af834e0d",
      "source_content": "Chaos Daemon provides the following gRPC interfaces to call:",
      "source_content_hash": "310786593645bb24b2d855c132001014278139c8cd6ee89bb83b09e15238b1d2",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Daemon 提供以下 gRPC 介面供呼叫："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6b0761da",
      "source_content": "```go\n// ChaosDaemonClient is the client API for ChaosDaemon service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.\n\ntype ChaosDaemonClient interface {\n\n   SetTcs(ctx context.Context, in *TcsRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   FlushIPSets(ctx context.Context, in *IPSetsRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   SetIptablesChains(ctx context.Context, in *IptablesChainsRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   SetTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   RecoverTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   ContainerKill(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   ContainerGetPid(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*ContainerResponse, error)\n   ExecStressors(ctx context.Context, in *ExecStressRequest, opts ...grpc.CallOption) (*ExecStressResponse, error)\n   CancelStressors(ctx context.Context, in *CancelStressRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n   ApplyIOChaos(ctx context.Context, in *ApplyIOChaosRequest, opts ...grpc.CallOption) (*ApplyIOChaosResponse, error)\n   ApplyHttpChaos(ctx context.Context, in *ApplyHttpChaosRequest, opts ...grpc.CallOption) (*ApplyHttpChaosResponse, error)\n   SetDNSServer(ctx context.Context, in *SetDNSServerRequest, opts ...grpc.CallOption) (*empty.Empty, error)\n}\n```",
      "source_content_hash": "4f577c03ed64b33b02847235f404a44b30d9ad8fa491d87baede4e619995397f",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_6b0761da"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7eac7922",
      "source_content": "### Network failure injection",
      "source_content_hash": "2aa0302dd78c12c659d251d65efbf6ce112ffee194fa9f3243d770f9b32bdb2b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 網路故障注入"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8f4e752e",
      "source_content": "From [pull request #41](https://github.com/chaos-mesh/chaos-mesh/pull/41), we know that Chaos Mesh injects network failures this way: it calls `pbClient.SetNetem` to encapsulate parameters into a request and send the request to the Chaos Daemon on the node for processing.",
      "source_content_hash": "3f19b793141466d5a8aa5dba3934b804d15323ae43f316c3f7375b86c30cadc3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "從 [pull request #41](https://github.com/chaos-mesh/chaos-mesh/pull/41) 可知，Chaos Mesh 透過呼叫 `pbClient.SetNetem` 將參數封裝成請求，再發送至節點上的 Chaos Daemon 處理，以此注入網路故障。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f211c69a",
      "source_content": "The network failure injection code is shown below as it appeared in 2019. As the project developed, the functions were distributed among several files.",
      "source_content_hash": "9cdcf93fcc0aee4d262006dac5417455cfac4903095c003fa70d57fa60438a63",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "以下展示的是 2019 年的網路故障注入程式碼，隨著專案發展，這些功能已分散至多個檔案。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "03859cae",
      "source_content": "```go\nfunc (r *Reconciler) applyPod(ctx context.Context, pod *v1.Pod, networkchaos *v1alpha1.NetworkChaos) error {\n   ...\n   pbClient := pb.NewChaosDaemonClient(c)\n   containerId := pod.Status.ContainerStatuses[0].ContainerID\n   netem, err := spec.ToNetem()\n   if err != nil {\n       return err\n   }\n   _, err = pbClient.SetNetem(ctx, &pb.NetemRequest{\n       ContainerId: containerId,\n       Netem:       netem,\n   })\n   return err\n}\n```",
      "source_content_hash": "6febb71cfad953d8f50eed50f3ddcd9b595fcb8b803b8f1148144f5f2134a444",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_03859cae"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9c70c953",
      "source_content": "In the `pkg/chaosdaemon` package, we can see how Chaos Daemon processes requests.",
      "source_content_hash": "cd0afd3c76f8d216177bfa1431efb49a21ebc312c9da17887044b31bc880d6e4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在 `pkg/chaosdaemon` 套件中，可觀察 Chaos Daemon 處理請求的機制。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d5f63a23",
      "source_content": "```go\nfunc (s *Server) SetNetem(ctx context.Context, in *pb.NetemRequest) (*empty.Empty, error) {\n   log.Info(\"Set netem\", \"Request\", in)\n   pid, err := s.crClient.GetPidFromContainerID(ctx, in.ContainerId)\n   if err != nil {\n       return nil, status.Errorf(codes.Internal, \"get pid from containerID error: %v\", err)\n   }\n   if err := Apply(in.Netem, pid); err != nil {\n       return nil, status.Errorf(codes.Internal, \"netem apply error: %v\", err)\n   }\n   return &empty.Empty{}, nil\n}\n\n// Apply applies a netem on eth0 in pid related namespace\n\nfunc Apply(netem *pb.Netem, pid uint32) error {\n   log.Info(\"Apply netem on PID\", \"pid\", pid)\n   ns, err := netns.GetFromPath(GenNetnsPath(pid))\n   if err != nil {\n       log.Error(err, \"failed to find network namespace\", \"pid\", pid)\n       return errors.Trace(err)\n   }\n   defer ns.Close()\n   handle, err := netlink.NewHandleAt(ns)\n   if err != nil {\n       log.Error(err, \"failed to get handle at network namespace\", \"network namespace\", ns)\n       return err\n   }\n   link, err := handle.LinkByName(\"eth0\") // TODO: check whether interface name is eth0\n   if err != nil {\n       log.Error(err, \"failed to find eth0 interface\")\n       return errors.Trace(err)\n   }\n   netemQdisc := netlink.NewNetem(netlink.QdiscAttrs{\n       LinkIndex: link.Attrs().Index,\n       Handle:    netlink.MakeHandle(1, 0),\n       Parent:    netlink.HANDLE_ROOT,\n   }, ToNetlinkNetemAttrs(netem))\n   if err = handle.QdiscAdd(netemQdisc); err != nil {\n       if !strings.Contains(err.Error(), \"file exists\") {\n           log.Error(err, \"failed to add Qdisc\")\n           return errors.Trace(err)\n       }\n   }\n   return nil\n}\n```",
      "source_content_hash": "05088062971933220f61b10bfda2915dd8472a83fd6ca5e51adde48373a179c1",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_d5f63a23"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1f92e934",
      "source_content": "Finally, the [`vishvananda/netlink` library](https://github.com/vishvananda/netlink) operates the Linux network interface to complete the job.",
      "source_content_hash": "5a0ee6e9a0de898aea43ad5ed5f81e0ad1ee375c0ba729d90cbd0a518fffd745",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "最終透過 [`vishvananda/netlink` 函式庫](https://github.com/vishvananda/netlink) 操作 Linux 網路介面來完成工作。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "45d5dee4",
      "source_content": "From here, `NetworkChaos` manipulates the Linux host network to create chaos. It includes tools such as iptables and ipset.",
      "source_content_hash": "ac80604f4ea73d3b6aa96db3b5e5ec437d32478d953f78d0b04e84b0a6101af4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "至此，`NetworkChaos` 透過操作 Linux 主機網路製造混亂，包含 iptables 和 ipset 等工具。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "83d7d3bc",
      "source_content": "In Chaos Daemon's Dockerfile, you can see the Linux tool chain that it depends on:",
      "source_content_hash": "2dcf8ae565abd1f8c3f6b8279e2396b850e10d57384f8dc7ee39295bbc589640",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在 Chaos Daemon 的 Dockerfile 中，可見其依賴的 Linux 工具鏈："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f24a5721",
      "source_content": "```dockerfile\nRUN apt-get update && \\\n   apt-get install -y tzdata iptables ipset stress-ng iproute2 fuse util-linux procps curl && \\\n   rm -rf /var/lib/apt/lists/*\n```",
      "source_content_hash": "2f72f092a9eceef73995b1cc31ba6cdbb2942f6c1c4ca292a9cbe37b39eeb32a",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f24a5721"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "73b08a54",
      "source_content": "### Stress test",
      "source_content_hash": "c97ea04b1c44bf04ccefe2df7a16280ef1c77c2540088c3737afcb5638e9b408",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 壓力測試"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7e031d10",
      "source_content": "Chaos Daemon also implements `StressChaos`. After the Controller Manager calculates the rules, it sends the task to the specific `Daemon`. The assembled parameters are shown below. They are combined into command execution parameters and appended to the `stress-ng` command for execution.",
      "source_content_hash": "2587f026bbe801fcb66db05d1f2910a76e6fab02ccbcfcd5314838a16372c5ff",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Daemon 也實作 `StressChaos`。Controller Manager 計算規則後，將任務發送至特定 `Daemon`。下方展示組裝後的參數，這些參數會合併為命令執行參數，附加至 `stress-ng` 命令執行。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "31df1954",
      "source_content": "```go\n// Normalize the stressors to comply with stress-ng\nfunc (in *Stressors) Normalize() (string, error) {\n   stressors := \"\"\n   if in.MemoryStressor != nil && in.MemoryStressor.Workers != 0 {\n       stressors += fmt.Sprintf(\" --vm %d --vm-keep\", in.MemoryStressor.Workers)\n       if len(in.MemoryStressor.Size) != 0 {\n           if in.MemoryStressor.Size[len(in.MemoryStressor.Size)-1] != '%' {\n               size, err := units.FromHumanSize(string(in.MemoryStressor.Size))\n               if err != nil {\n                   return \"\", err\n               }\n               stressors += fmt.Sprintf(\" --vm-bytes %d\", size)\n           } else {\n               stressors += fmt.Sprintf(\" --vm-bytes %s\",\n                   in.MemoryStressor.Size)\n           }\n       }\n       if in.MemoryStressor.Options != nil {\n           for _, v := range in.MemoryStressor.Options {\n               stressors += fmt.Sprintf(\" %v \", v)\n           }\n       }\n   }\n   if in.CPUStressor != nil && in.CPUStressor.Workers != 0 {\n       stressors += fmt.Sprintf(\" --cpu %d\", in.CPUStressor.Workers)\n       if in.CPUStressor.Load != nil {\n           stressors += fmt.Sprintf(\" --cpu-load %d\",\n               *in.CPUStressor.Load)\n       }\n       if in.CPUStressor.Options != nil {\n           for _, v := range in.CPUStressor.Options {\n               stressors += fmt.Sprintf(\" %v \", v)\n           }\n       }\n   }\n   return stressors, nil\n}\n```",
      "source_content_hash": "7608ec13e201fbdde6c97199220933471c731b7ae0c1e33dec42a55660aa64a7",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_31df1954"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d04a3ef5",
      "source_content": "The Chaos Daemon server side processes the function's execution command to call the official Go package `os/exec`. For details, see the [`pkg/chaosdaemon/stress_server_linux.go`](https://github.com/chaos-mesh/chaos-mesh/blob/98af3a0e7832a4971d6b133a32069539d982ef0a/pkg/chaosdaemon/stress_server_linux.go#L33) file. There is also a file with the same name that ends with darwin. `*_darwin` files prevent possible errors when the program is running on macOS.",
      "source_content_hash": "3ae42812b3895c91bef30d3497d5aa2d66b6c907727f9e9dbac122370a435308",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Daemon 伺服器端處理函式執行命令時，呼叫官方的 Go 套件 `os/exec`。詳見 [`pkg/chaosdaemon/stress_server_linux.go`](https://github.com/chaos-mesh/chaos-mesh/blob/98af3a0e7832a4971d6b133a32069539d982ef0a/pkg/chaosdaemon/stress_server_linux.go#L33) 檔案。另有以 darwin 結尾的同名檔案，`*_darwin` 檔案用於避免程式在 macOS 執行時可能產生的錯誤。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "dd78ef80",
      "source_content": "The code uses the [`shirou/gopsutil`](https://github.com/shirou/gopsutil) package to obtain the PID process status and reads the stdout and stderr standard outputs. I've seen this processing mode in [`hashicorp/go-plugin`](https://github.com/hashicorp/go-plugin), and go-plugin does this better.",
      "source_content_hash": "f64e6c15a9acae9d8bb47e002301ad745084127ba537ceb4d936db130177f721",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "程式碼使用 [`shirou/gopsutil`](https://github.com/shirou/gopsutil) 套件獲取 PID 程序狀態，並讀取 stdout 和 stderr 標準輸出。此處理模式可見於 [`hashicorp/go-plugin`](https://github.com/hashicorp/go-plugin)，而 go-plugin 的實作更為完善。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3f6b512a",
      "source_content": "### I/O fault injection",
      "source_content_hash": "f288433aab1965cdc918ab6406afd8ed818d32f454091fb978331d096be02dec",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### I/O 故障注入"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e91bdcd9",
      "source_content": "[Pull request #826](https://github.com/chaos-mesh/chaos-mesh/pull/826) introduces a new implementation of IOChaos, without the use of sidecar injection. It uses Chaos Daemon to directly manipulate the Linux namespace through the underlying commands of the [runc](https://github.com/opencontainers/runc) container and runs the [chaos-mesh/toda](https://github.com/chaos-mesh/toda) FUSE program developed by Rust to inject container I/O chaos. The [JSON-RPC 2.0](https://pkg.go.dev/github.com/ethereum/go-ethereum/rpc) protocol is used to communicate between toda and the control plane.",
      "source_content_hash": "c30c44356af74ec79783c137f5d629fe689bfd6bc3896a740fa90c292b68d2b1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "[Pull request #826](https://github.com/chaos-mesh/chaos-mesh/pull/826) 引入 IOChaos 的新實作方式，無需使用邊車注入。其透過 Chaos Daemon 以 [runc](https://github.com/opencontainers/runc) 容器的底層命令直接操作 Linux 命名空間，並執行由 Rust 開發的 [chaos-mesh/toda](https://github.com/chaos-mesh/toda) FUSE 程式來注入容器 I/O 混亂。toda 與控制平面間使用 [JSON-RPC 2.0](https://pkg.go.dev/github.com/ethereum/go-ethereum/rpc) 協定進行通訊。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "4bfb1f31",
      "source_content": "The new IOChaos implementation doesn't modify the Pod resources. When you define the IOChaos chaos experiment, for each Pod filtered by the selector field, a corresponding PodIOChaos resource is created. PodIoChaos' [owner reference](https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/) is the Pod. At the same time, a set of [finalizers](https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/) is added to PodIoChaos to release PodIoChaos resources before PodIoChaos is deleted.",
      "source_content_hash": "d68d2b6de983ce2ac0f8bd4d834eccbb966eab29a3a4add58b1ed7fc3b09415f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新的 IOChaos 實作不會修改 Pod 資源。當您定義 IOChaos 混沌實驗時，對於每個由選擇器欄位過濾出的 Pod，都會建立一個對應的 PodIOChaos 資源。PodIoChaos 的 [owner reference](https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/) 是該 Pod。同時，會為 PodIoChaos 加入一組 [finalizers](https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/)，以便在 PodIoChaos 被刪除前釋放其資源。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "253b84c5",
      "source_content": "```go\n// Apply implements the reconciler.InnerReconciler.Apply\n\nfunc (r *Reconciler) Apply(ctx context.Context, req ctrl.Request, chaos v1alpha1.InnerObject) error {\n   iochaos, ok := chaos.(*v1alpha1.IoChaos)\n   if !ok {\n       err := errors.New(\"chaos is not IoChaos\")\n       r.Log.Error(err, \"chaos is not IoChaos\", \"chaos\", chaos)\n       return err\n   }\n   source := iochaos.Namespace + \"/\" + iochaos.Name\n   m := podiochaosmanager.New(source, r.Log, r.Client)\n   pods, err := utils.SelectAndFilterPods(ctx, r.Client, r.Reader, &iochaos.Spec)\n   if err != nil {\n       r.Log.Error(err, \"failed to select and filter pods\")\n       return err\n   }\n   r.Log.Info(\"applying iochaos\", \"iochaos\", iochaos)\n   for _, pod := range pods {\n       t := m.WithInit(types.NamespacedName{\n           Name:      pod.Name,\n           Namespace: pod.Namespace,\n       })\n\n       // TODO: support chaos on multiple volume\n\n       t.SetVolumePath(iochaos.Spec.VolumePath)\n       t.Append(v1alpha1.IoChaosAction{\n           Type: iochaos.Spec.Action,\n           Filter: v1alpha1.Filter{\n               Path:    iochaos.Spec.Path,\n               Percent: iochaos.Spec.Percent,\n               Methods: iochaos.Spec.Methods,\n           },\n           Faults: []v1alpha1.IoFault{\n               {\n                   Errno:  iochaos.Spec.Errno,\n                   Weight: 1,\n               },\n           },\n           Latency:          iochaos.Spec.Delay,\n           AttrOverrideSpec: iochaos.Spec.Attr,\n           Source:           m.Source,\n       })\n       key, err := cache.MetaNamespaceKeyFunc(&pod)\n       if err != nil {\n           return err\n       }\n       iochaos.Finalizers = utils.InsertFinalizer(iochaos.Finalizers, key)\n   }\n   r.Log.Info(\"commiting updates of podiochaos\")\n   err = m.Commit(ctx)\n   if err != nil {\n       r.Log.Error(err, \"fail to commit\")\n       return err\n   }\n   r.Event(iochaos, v1.EventTypeNormal, utils.EventChaosInjected, \"\")\n   return nil\n}\n```",
      "source_content_hash": "983e23c2c907d5f8f92f9e2d8a7c875c58b16b29350791e0c5473405a025ef7f",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_253b84c5"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a5a5c34e",
      "source_content": "In the controller of the PodIoChaos resource, Controller Manager encapsulates the resource into parameters and calls the Chaos Daemon interface to process the parameters.",
      "source_content_hash": "19effb6ae14afd7e98149eb65cf40cf125a988ff915c12005c91d853d471d6f5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在 PodIoChaos 資源的控制器中，Controller Manager 將資源封裝成參數，並呼叫 Chaos Daemon 介面來處理這些參數。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "5ceeeefa",
      "source_content": "```go\n// Apply flushes io configuration on pod\n\nfunc (h *Handler) Apply(ctx context.Context, chaos *v1alpha1.PodIoChaos) error {\n   h.Log.Info(\"updating io chaos\", \"pod\", chaos.Namespace+\"/\"+chaos.Name, \"spec\", chaos.Spec)\n   ...\n   res, err := pbClient.ApplyIoChaos(ctx, &pb.ApplyIoChaosRequest{\n       Actions:     input,\n       Volume:      chaos.Spec.VolumeMountPath,\n       ContainerId: containerID,\n       Instance:  chaos.Spec.Pid,\n       StartTime: chaos.Spec.StartTime,\n   })\n   if err != nil {\n       return err\n   }\n   chaos.Spec.Pid = res.Instance\n   chaos.Spec.StartTime = res.StartTime\n   chaos.OwnerReferences = []metav1.OwnerReference{\n       {\n           APIVersion: pod.APIVersion,\n           Kind:       pod.Kind,\n           Name:       pod.Name,\n           UID:        pod.UID,\n       },\n   }\n   return nil\n}\n```",
      "source_content_hash": "38708a1a5eed1297817356f45c3920600832241724b2f1722bfb14739ffe0cb1",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_5ceeeefa"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c829cc4b",
      "source_content": "The `pkg/chaosdaemon/iochaos_server.go` file processes IOChaos. ​​In this file, a FUSE program needs to be injected into the container. As discussed in issue [#2305](https://github.com/chaos-mesh/chaos-mesh/issues/2305) on GitHub, the `/usr/local/bin/nsexec -l- p /proc/119186/ns/pid -m /proc/119186/ns/mnt - /usr/local/bin/toda --path /tmp --verbose info` command is executed to run the toda program under the same namespace as the Pod.",
      "source_content_hash": "1593389e2b647cff8446fe15740d5cf193227b7c52df682e4de6a6537ea72b30",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`pkg/chaosdaemon/iochaos_server.go` 檔案處理 IOChaos。在該檔案中，需要將一個 FUSE 程式注入容器中。如 GitHub 上的 issue [#2305](https://github.com/chaos-mesh/chaos-mesh/issues/2305) 所討論，會執行 `/usr/local/bin/nsexec -l- p /proc/119186/ns/pid -m /proc/119186/ns/mnt - /usr/local/bin/toda --path /tmp --verbose info` 命令，以在與 Pod 相同的命名空間下執行 toda 程式。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d27cbc80",
      "source_content": "```go\nfunc (s *DaemonServer) ApplyIOChaos(ctx context.Context, in *pb.ApplyIOChaosRequest) (*pb.ApplyIOChaosResponse, error) {\n   ...\n   pid, err := s.crClient.GetPidFromContainerID(ctx, in.ContainerId)\n   if err != nil {\n       log.Error(err, \"error while getting PID\")\n       return nil, err\n   }\n   args := fmt.Sprintf(\"--path %s --verbose info\", in.Volume)\n   log.Info(\"executing\", \"cmd\", todaBin+\" \"+args)\n   processBuilder := bpm.DefaultProcessBuilder(todaBin, strings.Split(args, \" \")...).\n       EnableLocalMnt().\n       SetIdentifier(in.ContainerId)\n   if in.EnterNS {\n       processBuilder = processBuilder.SetNS(pid, bpm.MountNS).SetNS(pid, bpm.PidNS)\n   }\n   ...\n\n   // Calls JSON RPC\n\n   client, err := jrpc.DialIO(ctx, receiver, caller)\n   if err != nil {\n       return nil, err\n   }\n   cmd := processBuilder.Build()\n   procState, err := s.backgroundProcessManager.StartProcess(cmd)\n   if err != nil {\n       return nil, err\n   }\n   ...\n}\n```",
      "source_content_hash": "a53cbcb58bcc3406d01fab68b0e7e39c63499364921a246627f732b89e77a45a",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_d27cbc80"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7f0cded5",
      "source_content": "The following code sample builds the running commands. These commands are the underlying namespace isolation implementation of runc:",
      "source_content_hash": "7991881ed8da30fefd0880270e50c53d209d12109feb4c159efc69a025501e27",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "以下程式碼範例建構了執行命令。這些命令是 runc 底層命名空間隔離的實作："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "647125dc",
      "source_content": "```go\n// GetNsPath returns corresponding namespace path\n\nfunc GetNsPath(pid uint32, typ NsType) string {\n   return fmt.Sprintf(\"%s/%d/ns/%s\", DefaultProcPrefix, pid, string(typ))\n}\n\n// SetNS sets the namespace of the process\n\nfunc (b *ProcessBuilder) SetNS(pid uint32, typ NsType) *ProcessBuilder {\n   return b.SetNSOpt([]nsOption{{\n       Typ:  typ,\n       Path: GetNsPath(pid, typ),\n   }})\n}\n\n// Build builds the process\n\nfunc (b *ProcessBuilder) Build() *ManagedProcess {\n   args := b.args\n   cmd := b.cmd\n   if len(b.nsOptions) > 0 {\n       args = append([]string{\"--\", cmd}, args...)\n       for _, option := range b.nsOptions {\n           args = append([]string{\"-\" + nsArgMap[option.Typ], option.Path}, args...)\n       }\n       if b.localMnt {\n           args = append([]string{\"-l\"}, args...)\n       }\n       cmd = nsexecPath\n   }\n   ...\n}\n```",
      "source_content_hash": "98c9ea8059d0409b23db959c59124c83bf6f2377df7fd01099338d4fae4e533e",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_647125dc"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "11e4b3f0",
      "source_content": "## Control plane",
      "source_content_hash": "d7c08e14c7d7de3b939b0849903b8128fbac570bd1c9026e09acf08595237d7d",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 控制平面"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6ba1041f",
      "source_content": "Chaos Mesh is an open-source chaos engineering system under the Apache 2.0 protocol. As discussed above, it has rich capabilities and a good ecosystem. The maintenance team developed the [`chaos-mesh/toda`](https://github.com/chaos-mesh/toda) FUSE based on the chaos system, the [`chaos-mesh/k8s_dns_chaos`](https://github.com/chaos-mesh/k8s_dns_chaos) CoreDNS chaos plug-in, and Berkeley Packet Filter (BPF)-based kernel error injection [`chaos-mesh/bpfki`](https://github.com/chaos-mesh/bpfki).",
      "source_content_hash": "29de334b2f31a201730766f5fa654319a30f58b0895d3590700f27c14b09f670",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 是一個基於 Apache 2.0 協議的開源混沌工程系統。如上所述，它具有豐富的功能和良好的生態系統。維護團隊基於該混沌系統開發了 [`chaos-mesh/toda`](https://github.com/chaos-mesh/toda) FUSE、[`chaos-mesh/k8s_dns_chaos`](https://github.com/chaos-mesh/k8s_dns_chaos) CoreDNS 混沌外掛，以及基於 Berkeley 封包過濾器 (BPF) 的核心錯誤注入 [`chaos-mesh/bpfki`](https://github.com/chaos-mesh/bpfki)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8f554a02",
      "source_content": "Now, I'll describe the server side code required to build an end-user-oriented chaos engineering platform. This implementation is only an example—not necessarily the best example. If you want to see the development practice on a real world platform, you can refer to Chaos Mesh's [Dashboard](https://github.com/chaos-mesh/chaos-mesh/tree/master/pkg/dashboard). It uses the [`uber-go/fx`](https://github.com/uber-go/fx) dependency injection framework and the controller runtime's manager mode.",
      "source_content_hash": "845c33b920268c8f854c28c71e3358506337be56f380b540746af954f8a244c2",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "現在，我將描述建構一個面向終端使用者的混沌工程平台所需的伺服器端程式碼。此實作僅為一個範例——並非最佳範例。如果您想查看真實平台上的開發實踐，可以參考 Chaos Mesh 的 [Dashboard](https://github.com/chaos-mesh/chaos-mesh/tree/master/pkg/dashboard)。它使用了 [`uber-go/fx`](https://github.com/uber-go/fx) 依賴注入框架以及控制器執行期的管理員模式。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "477f2f8b",
      "source_content": "### Key Chaos Mesh features",
      "source_content_hash": "06e65a3a8c1a46d6990bd70199738a9b12f159c5dd067ca6fd569438ccea3a20",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 關鍵的 Chaos Mesh 功能"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e6bf9a6c",
      "source_content": "As shown in the Chaos Mesh workflow below, we need to implement a server that sends YAML to the Kubernetes API. Chaos Controller Manager implements complex rule verification and rule delivery to Chaos Daemon. If you want to use Chaos Mesh with your own platform, you only need to connect to the process of creating CRD resources.",
      "source_content_hash": "4dd90ae18d02081b557eb3c6b3cde0f392bc3a45b1e5e0c948743c2de2d90afd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "如下方的 Chaos Mesh 工作流程所示，我們需要實作一個伺服器來發送 YAML 到 Kubernetes API。Chaos Controller Manager 實作了複雜的規則驗證和規則傳遞給 Chaos Daemon。如果您想在自己的平台中使用 Chaos Mesh，您只需要連接到建立 CRD 資源的流程。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "17b95bd5",
      "source_content": "![Chaos Mesh's basic workflow](/img/blog/chaos-mesh-basic-workflow.png)",
      "source_content_hash": "6b8c5b9e445b273fe43f8bcbc1c3598d8726e9c74b686afc990d4f99eba5c829",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![Chaos Mesh 的基本工作流程](/img/blog/chaos-mesh-basic-workflow.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "5fe249dd",
      "source_content": "Let's take a look at the example on the Chaos Mesh website:",
      "source_content_hash": "be736d6263951aeb5d4b4e8e2885b05e2175357faf107edf87b73eb2e0d74efc",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "讓我們來看一下 Chaos Mesh 網站上的範例："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "79094e7f",
      "source_content": "```go\nimport (\n   \"context\"\n   \"github.com/pingcap/chaos-mesh/api/v1alpha1\"\n   \"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\nfunc main() {\n   ...\n   delay := &chaosv1alpha1.NetworkChaos{\n       Spec: chaosv1alpha1.NetworkChaosSpec{...},\n   }\n   k8sClient := client.New(conf, client.Options{ Scheme: scheme.Scheme })\n   k8sClient.Create(context.TODO(), delay)\n   k8sClient.Delete(context.TODO(), delay)\n}\n```",
      "source_content_hash": "4c22a4025e58e734cdc5c765dd7adaf46deea1b6dd89df1c9ba0b20c7214fdc9",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_79094e7f"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9d789e30",
      "source_content": "Chaos Mesh provides APIs corresponding to all CRDs. We use the [controller-runtime](https://github.com/kubernetes-sigs/controller-runtime) developed by Kubernetes [API Machinery SIG](https://github.com/kubernetes/community/tree/master/sig-api-machinery) to simplify the interaction with the Kubernetes API.",
      "source_content_hash": "b7967a52c78534f411c789e98f98c28886334a4886751429ed7c8e8b2155f8a5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "Chaos Mesh 提供了對應所有 CRD 的 API。我們使用由 Kubernetes [API Machinery SIG](https://github.com/kubernetes/community/tree/master/sig-api-machinery) 開發的 [controller-runtime](https://github.com/kubernetes-sigs/controller-runtime) 來簡化與 Kubernetes API 的互動。",
          "reason": "URL for a 'link' was changed from 'https://github.com/kubernetes-sigs/controller-runtime' to 'https://github.com/kubernetes/community/tree/master/sig-api-machinery'.",
          "timestamp": "2025-07-04T06:49:59.315912+00:00"
        }
      }
    },
    {
      "segment_id": "b8d76c94",
      "source_content": "### Inject chaos",
      "source_content_hash": "b3b6ae663f0be18b4feaacfed3a36322b593a1a9f94a59645a24bab0e7355b72",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 注入混沌"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cff30da4",
      "source_content": "Suppose we want to create a `PodKill` resource by calling a program. After the resource is sent to the Kubernetes API server, it passes Chaos Controller Manager's [validating admission controller](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to verify data. When we create a chaos experiment, if the admission controller fails to verify the input data, it returns an error to the client. For specific parameters, you can read [Create experiments using YAML configuration files](https://chaos-mesh.org/docs/simulate-pod-chaos-on-kubernetes/#create-experiments-using-yaml-configuration-files).",
      "source_content_hash": "0a27b29b112550a68a38ec238bce68d0821b7d09c127b324de7f2043a89b70a1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "假設我們希望透過呼叫程式來建立一個 `PodKill` 資源。當資源傳送至 Kubernetes API 伺服器後，會經過 Chaos Controller Manager 的 [驗證准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) 進行資料驗證。建立混沌實驗時，若准入控制器無法驗證輸入資料，會向用戶端返回錯誤。具體參數可參考 [使用 YAML 設定檔案建立實驗](https://chaos-mesh.org/docs/simulate-pod-chaos-on-kubernetes/#create-experiments-using-yaml-configuration-files)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "36a7c2db",
      "source_content": "`NewClient` creates a Kubernetes API client. You can refer to this example:",
      "source_content_hash": "3f677eb3d9a07eaff45ac414d3bd7cea1a265a3ddc17c2af6a06e2f23b9a3e64",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`NewClient` 會建立一個 Kubernetes API 用戶端。可參考以下範例："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "26463657",
      "source_content": "```go\npackage main\n\nimport (\n   \"context\"\n   \"controlpanel\"\n   \"log\"\n   \"github.com/chaos-mesh/chaos-mesh/api/v1alpha1\"\n   \"github.com/pkg/errors\"\n   metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nfunc applyPodKill(name, namespace string, labels map[string]string) error {\n   cli, err := controlpanel.NewClient()\n   if err != nil {\n       return errors.Wrap(err, \"create client\")\n   }\n   cr := &v1alpha1.PodChaos{\n       ObjectMeta: metav1.ObjectMeta{\n           GenerateName: name,\n           Namespace:    namespace,\n       },\n       Spec: v1alpha1.PodChaosSpec{\n           Action: v1alpha1.PodKillAction,\n           ContainerSelector: v1alpha1.ContainerSelector{\n               PodSelector: v1alpha1.PodSelector{\n                   Mode: v1alpha1.OnePodMode,\n                   Selector: v1alpha1.PodSelectorSpec{\n                       Namespaces:     []string{namespace},\n                       LabelSelectors: labels,\n                   },\n               },\n           },\n       },\n   }\n\n   if err := cli.Create(context.Background(), cr); err != nil {\n       return errors.Wrap(err, \"create podkill\")\n   }\n   return nil\n}\n```",
      "source_content_hash": "e6f54cc5b92b88d411beaca338354982c99a1cac05db7b30728b0a67dc31f605",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_26463657"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "929f4d2d",
      "source_content": "The log output of the running program is:",
      "source_content_hash": "3b38f55722c5a565d101828f472e3edbce12f8a421220ba009b49e7b9bdd2495",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "執行程式的日誌輸出為："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c4c948f3",
      "source_content": "```bash\nI1021 00:51:55.225502   23781 request.go:665] Waited for 1.033116256s due to client-side throttling, not priority and fairness, request: GET:https://***\n2021/10/21 00:51:56 apply podkill\n```",
      "source_content_hash": "d3e54cbd3baebed54d1d7f6fe22db926663d0e73fc32af80de69d0391bf9c11b",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_c4c948f3"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "92bceadb",
      "source_content": "Use kubectl to check the status of the `PodKill` resource:",
      "source_content_hash": "9474603d084a51d7df319ff803705b89426c3930a07e24517fa43f3ef9d80d43",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "使用 kubectl 檢查 `PodKill` 資源的狀態："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f291b8f1",
      "source_content": "```bash\n$ k describe podchaos.chaos-mesh.org -n dev podkillvjn77\nName:         podkillvjn77\nNamespace:    dev\nLabels:       <none>\nAnnotations:  <none>\nAPI Version:  chaos-mesh.org/v1alpha1\nKind:         PodChaos\n\nMetadata:\n Creation Timestamp:  2021-10-20T16:51:56Z\n Finalizers:\n   chaos-mesh/records\n Generate Name:     podkill\n Generation:        7\n Resource Version:  938921488\n Self Link:         /apis/chaos-mesh.org/v1alpha1/namespaces/dev/podchaos/podkillvjn77\n UID:               afbb40b3-ade8-48ba-89db-04918d89fd0b\n\nSpec:\n Action:        pod-kill\n Grace Period:  0\n Mode:          one\n Selector:\n   Label Selectors:\n     app:  nginx\n   Namespaces:\n     dev\n\nStatus:\n Conditions:\n   Reason:\n   Status:  False\n   Type:    Paused\n   Reason:\n   Status:  True\n   Type:    Selected\n   Reason:\n   Status:  True\n   Type:    AllInjected\n   Reason:\n   Status:  False\n   Type:    AllRecovered\n\n Experiment:\n   Container Records:\n     Id:            dev/nginx\n     Phase:         Injected\n     Selector Key:  .\n   Desired Phase:   Run\n\nEvents:\n Type    Reason           Age    From          Message\n ----    ------           ----   ----          -------\n Normal  FinalizerInited  6m35s  finalizer     Finalizer has been inited\n Normal  Updated          6m35s  finalizer     Successfully update finalizer of resource\n Normal  Updated          6m35s  records       Successfully update records of resource\n Normal  Updated          6m35s  desiredphase  Successfully update desiredPhase of resource\n Normal  Applied          6m35s  records       Successfully apply chaos for dev/nginx\n Normal  Updated          6m35s  records       Successfully update records of resource\n```",
      "source_content_hash": "02b4c2d2e0c18e4183e5dd6e4d696f59e2a831e9d67016538f0dc5d3f519c172",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f291b8f1"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ec74b948",
      "source_content": "The control plane also needs to query and acquire Chaos resources, so that platform users can view all chaos experiments' implementation status and manage them. To achieve this, we can call the `REST` API to send the `Get` or `List` request. But in practice, we need to pay attention to the details. At our company, we've noticed that each time the controller requests the full amount of resource data, the load of the Kubernetes API server increases.",
      "source_content_hash": "5a85d4b6196392cb2dcc71e6946a3737290b5e6eb79a84d9ad51aba43c932b66",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "控制平面還需查詢並取得混沌資源，讓平台使用者能檢視所有混沌實驗的執行狀態並進行管理。為實現此功能，我們可呼叫 `REST` API 發送 `Get` 或 `List` 請求。但在實務中需注意細節：我們公司觀察到，每當控制器請求完整資源資料時，Kubernetes API 伺服器的負載會明顯升高。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "413a2594",
      "source_content": "I recommend that you read the [How to use the controller-runtime client](https://zoetrope.github.io/kubebuilder-training/controller-runtime/client.html) (in Japanese) controller runtime tutorial. If you don't understand Japanese, you can still learn a lot from the tutorial by reading the source code. It covers many details. For example, by default, the controller runtime reads kubeconfig, flags, environment variables, and the service account automatically mounted in the Pod from multiple locations. [Pull request #21](https://github.com/armosec/kubescape/pull/21) for [`armosec/kubescape`](https://github.com/armosec/kubescape) uses this feature. This tutorial also includes common operations, such as how to paginate, update, and overwrite objects. I haven't seen any English tutorials that are so detailed.",
      "source_content_hash": "c3c035c1790256831f15d5dc20265ef756c4fe2a2b42fb81174a6a4dc73d35f6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "建議閱讀 [controller-runtime 用戶端使用教學](https://zoetrope.github.io/kubebuilder-training/controller-runtime/client.html)（日文版）。即使不懂日文，透過閱讀原始碼仍能從中學到許多細節。例如預設情況下，controller runtime 會從多個位置讀取 kubeconfig、標誌、環境變數，以及自動掛載於 Pod 中的服務帳戶。[`armosec/kubescape`](https://github.com/armosec/kubescape) 的 [Pull request #21](https://github.com/armosec/kubescape/pull/21) 即運用此特性。該教學還涵蓋常見操作，如分頁、更新與覆寫物件的方法。目前尚未見到如此詳盡的英文教學。",
          "reason": "URL for a 'link' was changed from 'https://github.com/armosec/kubescape/pull/21' to 'https://github.com/armosec/kubescape'.",
          "timestamp": "2025-07-04T06:49:59.315942+00:00"
        }
      }
    },
    {
      "segment_id": "3026c350",
      "source_content": "Here are examples of `Get` and `List` requests:",
      "source_content_hash": "ce3e3f5c7eba014ea99c6e7db80ffbe7e4c26f5882e51cbe7fc579a5ac56a9fa",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "以下是 `Get` 與 `List` 請求的範例："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "02cf064a",
      "source_content": "```go\npackage controlpanel\n\nimport (\n   \"context\"\n   \"github.com/chaos-mesh/chaos-mesh/api/v1alpha1\"\n   \"github.com/pkg/errors\"\n   \"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\nfunc GetPodChaos(name, namespace string) (*v1alpha1.PodChaos, error) {\n   cli := mgr.GetClient()\n   item := new(v1alpha1.PodChaos)\n   if err := cli.Get(context.Background(), client.ObjectKey{Name: name, Namespace: namespace}, item); err != nil {\n       return nil, errors.Wrap(err, \"get cr\")\n   }\n   return item, nil\n}\n\nfunc ListPodChaos(namespace string, labels map[string]string) ([]v1alpha1.PodChaos, error) {\n   cli := mgr.GetClient()\n   list := new(v1alpha1.PodChaosList)\n   if err := cli.List(context.Background(), list, client.InNamespace(namespace), client.MatchingLabels(labels)); err != nil {\n       return nil, err\n   }\n   return list.Items, nil\n}\n```",
      "source_content_hash": "8b313300d3168432b966511cbca276e65db21406e6014e1c12dc8a09fccb4239",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_02cf064a"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c3d63f8a",
      "source_content": "This example uses the manager. This mode prevents the cache mechanism from repetitively fetching large amounts of data. The following [figure](https://zoetrope.github.io/kubebuilder-training/controller-runtime/client.html) shows the workflow:",
      "source_content_hash": "e5f50c5a30b19e7d8c094f2e2e46add0b2e07a5d0a3a37701a15506b9fab1fd9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "此範例採用管理器模式，可避免快取機制重複獲取大量資料。下圖 [figure](https://zoetrope.github.io/kubebuilder-training/controller-runtime/client.html) 展示其工作流程："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "29cab9f9",
      "source_content": "1. Get the Pod.",
      "source_content_hash": "fe6b9894c3990f3c0cb42e46e4c52f3afa9fa0a853707d8f72ad1304f60bdcb9",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 取得 Pod。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e82894cf",
      "source_content": "2. Get the `List` request's full data for the first time.",
      "source_content_hash": "2ef9b748f786f0e86b6da76419ddffc59ade8dc7721c71626af1a25ebbd5897f",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 首次取得 `List` 請求的完整資料。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8b031d39",
      "source_content": "3. Update the cache when the watch data changes.",
      "source_content_hash": "9f6cb382ae0f72882cf2415e9a3b8c92dd02971351d6599281c48bfbc34c363c",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 當監視資料變更時更新快取。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d1d04358",
      "source_content": "![List request](/img/blog/list-request.png)",
      "source_content_hash": "fcdc40e442673d97f4a44c3b519282a7e387b46dad41e6d0100564f04d329b11",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![List request](/img/blog/list-request.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "18c0bc86",
      "source_content": "### Orchestrate chaos",
      "source_content_hash": "18c38c9bf6f95e7557669602d0749b7cc0cb330e2523a515d6e2dd97d017db6e",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 編排混沌"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "16ad9b8d",
      "source_content": "The container runtime interface (CRI) container runtime provides strong underlying isolation capabilities that can support the stable operation of the container. But for more complex and scalable scenarios, container orchestration is required. Chaos Mesh also provides [`Schedule`](https://chaos-mesh.org/docs/define-scheduling-rules/) and [`Workflow`](https://chaos-mesh.org/docs/create-chaos-mesh-workflow/) features. Based on the set `Cron` time, `Schedule` can trigger faults regularly and at intervals. `Workflow` can schedule multiple fault tests like Argo Workflows.",
      "source_content_hash": "f63d14605575704a07737da71274aa17eb6099ca15ee103830c6971066e7eb86",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "容器執行時期介面 (CRI) 提供強大的底層隔離能力以維持容器穩定運行，但面對更複雜的可擴展場景時，需進行容器編排。Chaos Mesh 還提供 [`Schedule`](https://chaos-mesh.org/docs/define-scheduling-rules/) 與 [`Workflow`](https://chaos-mesh.org/docs/create-chaos-mesh-workflow/) 功能：基於設定的 `Cron` 時間，`Schedule` 可定期或間隔觸發故障；`Workflow` 則能像 Argo Workflows 般排程多個故障測試。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "dd65b89b",
      "source_content": "Chaos Controller Manager does most of the work for us. The control plane mainly manages these YAML resources. You only need to consider the features you want to provide to end users.",
      "source_content_hash": "038dbdc3f4f42492e95bab7e2f057a5f66952a279a701f2c29a4242c23fe34d9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Controller Manager 已處理大部分工作，控制平面主要管理這些 YAML 資源。您只需專注於提供給終端使用者的功能設計。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d8336f3e",
      "source_content": "### Platform features",
      "source_content_hash": "6af2ada91fd33d7d698a1c59dbf7e7caec89425c4af30ed455fbf809e1cd0011",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 平台功能"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "09fde125",
      "source_content": "The following figure shows Chaos Mesh Dashboard. We need to consider what features the platform should provide to end users.",
      "source_content_hash": "d92557a97d454520492765845960dd893c78f08d1fa25f6594bdd31269ec494a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "下圖展示 Chaos Mesh 儀表板，我們需思考平台應提供哪些功能給終端使用者。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "36ecfe62",
      "source_content": "![Chaos Mesh Dashboard](/img/blog/chaos-mesh-dashboard-k8s.png)",
      "source_content_hash": "fa07a09a63fd361f9f516f1838913e64a62b2d4e1e4ac9e18d344ff4b3abf889",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![Chaos Mesh Dashboard](/img/blog/chaos-mesh-dashboard-k8s.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "db40fdec",
      "source_content": "From the Dashboard, we know that the platform may have these features:",
      "source_content_hash": "afa6bf4a725ca313ca2133ee468061ebe3101b1e3e412756f9c9bc75d522e745",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "由儀表板可知，平台可能具備以下功能："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c83bac1a",
      "source_content": "- Chaos injection",
      "source_content_hash": "8905362654df31352441f8b55e5c44e7f04c3f7bd49ef3390065409798c4ee0a",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 混沌注入"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "23de710e",
      "source_content": "- Pod crash",
      "source_content_hash": "0abb5a3ab8cf5f8a178585113cd57821ecdefb1bdf47274da353ea4c2675e5cc",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- Pod 崩潰"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "006f0976",
      "source_content": "- Network failure",
      "source_content_hash": "f68f36670902f244ce2f42f40c6ccf99638b71518b7ffb031c61f02e86d69c04",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 網路故障"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "25621106",
      "source_content": "- Load test",
      "source_content_hash": "d96b2264a7e5fc46e968c4148f4c2e1155884daedd7d18242062e7db1fd42e25",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 負載測試"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "279d2cbc",
      "source_content": "- I/O failure",
      "source_content_hash": "52a982f6f3062f4997e25cf4faa75695c1f69cd8510662c7f3167f55f638ebea",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- I/O 故障"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ce70fa8d",
      "source_content": "- Event tracking",
      "source_content_hash": "a5a6a1c21497b2b3f93b962052e5687c9922696cf05f80facde1f6792e8fd2b5",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 事件追蹤"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1b02a81d",
      "source_content": "- Associated alarm",
      "source_content_hash": "9a04c5a65c784fdcc7ca66d399577045d7f3ab7ccc92605975ee1e897d782c64",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 關聯警報"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8e81e296",
      "source_content": "- Timing telemetry",
      "source_content_hash": "75b4b33e10fe982a2ca955b5e6f10b85fa664c23405d11fefb79d0ddbdbee467",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 時序遙測"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "96a98088",
      "source_content": "If you are interested in Chaos Mesh and would like to improve it, join its [Slack channel](https://slack.cncf.io/) (#project-chaos-mesh) or submit your pull requests or issues to its [GitHub repository](https://github.com/chaos-mesh/chaos-mesh).",
      "source_content_hash": "79bbe381e6aa52782cfa8893cd4d4f562556dab9abd12fd9aa9293707ed586fd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若您對 Chaos Mesh 感興趣並希望參與改進，請加入其 [Slack 頻道](https://slack.cncf.io/) (#project-chaos-mesh) 或提交 pull request 與問題至 [GitHub 倉庫](https://github.com/chaos-mesh/chaos-mesh)。"
      },
      "invalid_translations": {}
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-blog/2021-12-10-implement-chaos-engineering-in-k8s.md",
  "last_updated_timestamp": "2025-07-04T06:49:59.315973+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "ae13e1a4f80105f1621a2eb77d731ffca386b1bfcbe31124119923e2a7d4be3b"
  }
}