{
  "source_file_path_relative_to_docusaurus_root": "blog/2021-01-08-how-to-simulate-io-faults-at-runtime.md",
  "source_file_content_hash": "80c42f9c79bb41d54431409e6bc9fe5ddc624a729fc0765b6294d61f88c64a1f",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\nslug: /how-to-simulate-io-faults-at-runtime\ntitle: 'How to Simulate I/O Faults at Runtime'\nauthors: keaoyang\nimage: /img/blog/how-to-simulate-io-faults-at-runtime.jpg\ntags: [Chaos Mesh, Chaos Engineering, Fault Injection]\n---",
      "source_content_hash": "1b90ca0d6b28c5f20a420e01fc899e753d569b63f7d191be78a40e4e65c0840b",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_58cfcc64"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "53eaf0e1",
      "source_content": "![Chaos Engineering - How to simulate I/O faults at runtime](/img/blog/how-to-simulate-io-faults-at-runtime.jpg)",
      "source_content_hash": "21a7e5ad75c0a59b70392505527fe014c4b6082dc9160721dba0cfcae6a5a513",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![混沌工程 - 如何在運行時模擬 I/O 故障](/img/blog/how-to-simulate-io-faults-at-runtime.jpg)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8ac585fb",
      "source_content": "In a production environment, filesystem faults might occur due to various incidents such as disk failures and administrator errors. As a Chaos Engineering platform, Chaos Mesh has supported simulating I/O faults in a filesystem ever since its early versions. By simply adding an IOChaos CustomResourceDefinition (CRD), we can watch how the filesystem fails and returns errors.",
      "source_content_hash": "3b856c410efb56b55ea42e782e4e2913a2b9eaf979d5d9b9c0bbb07bab3a1c87",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在生產環境中，檔案系統故障可能因多種事件而發生，例如磁碟故障和管理員錯誤。作為混沌工程平台，Chaos Mesh 從早期版本就支援模擬檔案系統中的 I/O 故障。只需新增 IOChaos 自訂資源定義（CRD），我們就能觀察檔案系統如何失敗並回傳錯誤。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3e6699f4",
      "source_content": "<!--truncate-->",
      "source_content_hash": "f5cded2aa7e288e395fe4f67f9dabda2281904b2f5358d07302b3aa8be0acdfa",
      "node_type": "comment",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_3e6699f4"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cf898102",
      "source_content": "However, before Chaos Mesh 1.0, this experiment was not easy and may have consumed a lot of resources. We needed to inject sidecar containers to the Pod through the mutating admission webhooks and rewrite the `ENTRYPOINT` command. Even if no fault was injected, the injected sidecar container caused a substantial amount of overhead.",
      "source_content_hash": "290f91322744f79710b6e351bf51c2adb172debc23ec3feba6411f46514b2a29",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "然而在 Chaos Mesh 1.0 之前，此實驗並不容易且可能消耗大量資源。我們需透過突變許可 Webhook 將邊車容器注入 Pod，並重寫 `ENTRYPOINT` 指令。即使未注入故障，注入的邊車容器也會造成顯著系統開銷。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "42ad8e83",
      "source_content": "Chaos Mesh 1.0 has changed all this. Now, we can use IOChaos to inject faults to a filesystem at runtime. This simplifies the process and greatly reduces system overhead. This blog post introduces how we implement the IOChaos experiment without using a sidecar.",
      "source_content_hash": "e551f1e922440b5ccc5cf6e303adaa3738993608efb13740d083730e230631f5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 1.0 改變了這一切。現在我們可使用 IOChaos 在運行時將故障注入檔案系統，簡化流程並大幅降低系統開銷。本文將介紹如何在不使用邊車的情況下實作 IOChaos 實驗。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "aee0e40d",
      "source_content": "## I/O fault injection",
      "source_content_hash": "6be97b4662c4970a8d5aa97dd85297379dad3df6003dc96659df0ccf1548fae7",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## I/O 故障注入"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f5f6d2ce",
      "source_content": "To simulate I/O faults at runtime, we need to inject faults into a filesystem after the program starts [system calls](https://man7.org/linux/man-pages/man2/syscall.2.html) (such as reads and writes) but before the call requests arrive at the target filesystem. We can do that in one of two ways:",
      "source_content_hash": "a6428ff1e61e1e336ce1ee44e5bbafd7101b9e7916ede6b6d6b7d45678c261b6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "為在運行時模擬 I/O 故障，需在程式啟動[系統呼叫](https://man7.org/linux/man-pages/man2/syscall.2.html)（如讀寫）後、但請求抵達目標檔案系統前注入故障。我們有兩種實現方式："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8b31a2bd",
      "source_content": "- Use Berkeley Packet Filter (BPF); however, it [cannot be used to inject delay](https://github.com/iovisor/bcc/issues/2336).",
      "source_content_hash": "8d3407e0ce5dc100cbeca2a0fa35b0e55a168e5244a90511a0c0369887c07f60",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 使用柏克萊封包過濾器（BPF）；但其[無法注入延遲](https://github.com/iovisor/bcc/issues/2336)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d7f0c63d",
      "source_content": "- Add a filesystem layer called ChaosFS before the target filesystem. ChaosFS uses the target filesystem as the backend and receives requests from the operating system. The entire call link is **target program syscall** -> **Linux kernel** -> **ChaosFS** -> **target filesystem**. Because ChaosFS is customizable, we can inject delays and errors as we want. Therefore, ChaosFS is our choice.",
      "source_content_hash": "f169786bf6552cbbe895b7114f83a025bb27cccd4102304cf0f54f9a6abad514",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 在目標檔案系統前新增名為 ChaosFS 的檔案系統層。ChaosFS 以目標檔案系統為後端接收作業系統請求，完整呼叫鏈為**目標程式系統呼叫** -> **Linux 核心** -> **ChaosFS** -> **目標檔案系統**。因 ChaosFS 可客製化，我們能任意注入延遲與錯誤，故選擇此方案。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ccc88b4c",
      "source_content": "But ChaosFS has several problems:",
      "source_content_hash": "334ae1ff85707fab8bbd15119450f3c753e877898ef4eb1886d4470c9f342efa",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "但 ChaosFS 存在多項問題："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "882f8186",
      "source_content": "- If ChaosFS reads and writes files in the target filesystem, we need to [mount](https://man7.org/linux/man-pages/man2/mount.2.html) ChaosFS to a different path than the target path specified in the Pod configuration. ChaosFS **cannot** be mounted to the path of the target directory.",
      "source_content_hash": "5aef835b9c1a36be0a1990207233928cc5398d2e2eddb082f09c5bcbc9fb812b",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 若 ChaosFS 需讀寫目標檔案系統檔案，必須將 ChaosFS [掛載](https://man7.org/linux/man-pages/man2/mount.2.html)至與 Pod 設定目標路徑不同的位置。ChaosFS **無法**直接掛載至目標目錄路徑。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2523feeb",
      "source_content": "- We need to mount ChaosFS **before** the target program starts running. This is because the newly-mounted ChaosFS takes effect only on files that are newly opened by the program in the target filesystem.",
      "source_content_hash": "15cd91ea69a274cf21582163805f3b468ed0c8d1491236abb311baee00e3fc97",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 需**在**目標程式開始運行**前**掛載 ChaosFS。因新掛載的 ChaosFS 僅對程式在目標檔案系統中新開啟的檔案生效。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "5df3dd43",
      "source_content": "- We need to mount ChaosFS to the target containter's `mnt` namespace. For details, see [mount_namespaces(7) — Linux manual page](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html).",
      "source_content_hash": "0ad2c4b146cd810ff821f860edf7535be42fb398442e9b95cf93561fb2c0a3a6",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 需將 ChaosFS 掛載至目標容器的 `mnt` 命名空間。詳見 [mount_namespaces(7) — Linux 手冊頁](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "73ab96a3",
      "source_content": "Before Chaos Mesh 1.0, we used the [mutating admission webhook](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/) to implement IOChaos. This technique addressed the three problems lists above and allowed us to:",
      "source_content_hash": "8fe203e6c3b085ad28ab6edd31595e5d77748cd646177316973546d460d5a520",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 1.0 前，我們使用[突變許可 Webhook](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/) 實作 IOChaos，此技術解決上述三問題並實現："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c0463e48",
      "source_content": "- Run scripts in the target container. This action changed the target directory of the ChaosFS's backend filesystem (for example, from `/mnt/a` to `/mnt/a_bak`) so that we could mount ChaosFS to the target path (`/mnt/a`). Modify the command that starts the Pod. For example, we could modify the original command `/app` to `/waitfs.sh /app`.",
      "source_content_hash": "39082158e1a2c3b46ec719c28d63b4fb52627455ec6bb220f2ca9f95ffac0ce1",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 在目標容器執行指令碼：變更 ChaosFS 後端檔案系統目標目錄（如將 `/mnt/a` 改為 `/mnt/a_bak`），使 ChaosFS 能掛載至目標路徑（`/mnt/a`）。修改 Pod 啟動指令，如將原始指令 `/app` 改為 `/waitfs.sh /app`。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2d89eb89",
      "source_content": "- The `waitfs.sh` script kept checking whether the filesystem was successfully mounted. If it was mounted, `/app` was started.",
      "source_content_hash": "70a5b5b6a0bd286e743ffee9d62857a9fe769f42178d74327c88459ac4255d8b",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- `waitfs.sh` 指令碼持續檢查檔案系統是否成功掛載，掛載成功後才啟動 `/app`。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cc5346ac",
      "source_content": "- Add a new container in the Pod to run ChaosFS. This container needed to share a volume with the target container (for example, `/mnt`), and then we mounted this volume to the target directory (for example, `/mnt/a`). We also properly enabled [mount propagation](https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation) for this volume's mount to penetrate the share to host and then penetrate slave to the target.",
      "source_content_hash": "e3a75814dabaf08ba4b774a6e58aeea5423d298ede4098c7cb7ee99d952e1e71",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 在 Pod 新增執行 ChaosFS 的容器：此容器需與目標容器共享卷（如 `/mnt`），並將卷掛載至目標目錄（如 `/mnt/a`）。同時啟用[掛載傳播](https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation)，使卷掛載能穿透至主機再傳遞至目標。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "135468ee",
      "source_content": "These three approaches allowed us to inject I/O faults while the program was running. However, the injection was far from convenient:",
      "source_content_hash": "36eb68b5745bb3b986ef3e87922c5f49180c87e9bd88d07be4f3e98277015bf5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "這三種方法讓我們能在程式運行時注入 I/O 故障，但注入過程遠非便捷："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "4a0e7cce",
      "source_content": "- We could only inject faults into a volume subdirectory, not into the entire volume. The workaround was to replace `mv` (rename) with `mount move` to move the mount point of the target volume.",
      "source_content_hash": "1d5debac8231ed18cada61a6f5e42b57cf73258aeb961050870db471593b0ec6",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "- 僅能注入到卷的子目錄，無法覆蓋整個卷。解決方案是用 `mount move` 取代 `mv`（重新命名）來移動目標卷的掛載點。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`mv`', Translation: '`mount move`'.",
          "timestamp": "2025-07-04T06:49:59.310833+00:00"
        }
      }
    },
    {
      "segment_id": "c4706327",
      "source_content": "- We had to explicitly write commands in the Pod rather than implicitly use the image commands. Otherwise, the `/waitfs.sh` script could not properly start the program after the filesystem was mounted.",
      "source_content_hash": "3a0d618f3f17f68e4ae32dd093c773534ac67e9dc3dbde13608ecc0dc3fbc88f",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 必須在 Pod 中明確寫入指令，而非隱式使用鏡像指令。否則 `/waitfs.sh` 腳本無法在檔案系統掛載後正確啟動程式。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e78e6061",
      "source_content": "- The corresponding container needed to have a proper configuration for mount propagation. Due to potential privacy and security issues, we **could not** modify the configuration via the mutating admission webhook.",
      "source_content_hash": "6d26df185badc5855cbad41e7f38ca1ea07834ece97dfc0b9d839d8a28944057",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 對應容器需正確配置掛載傳播。基於潛在隱私與安全問題，我們**無法**透過突變准入 Webhook 修改配置。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c6e6fb16",
      "source_content": "- The injection configuration was troublesome. Worse still, we had to create a new Pod after the configuration was able to inject faults.",
      "source_content_hash": "681298860080f5de74c110eb43cf70915f67aa49796e34d8a26fff205b89371a",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 注入配置過程繁瑣，更糟的是必須在配置生效後創建新的 Pod 才能注入故障。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6c00797f",
      "source_content": "- We could not withdraw ChaosFS while the program was running. Even if no fault or error was injected, the performance was greatly affected.",
      "source_content_hash": "3ef8242c6b7e63de63319279dbbda7d9bf8819a6bd37eff592192088281996bc",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 無法在程式運行時撤回 ChaosFS。即使未注入任何故障或錯誤，效能仍會大幅下降。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8bddee80",
      "source_content": "## Inject I/O faults without the mutating admission webhook",
      "source_content_hash": "d7d5a475f5098bc9006f6ac737ef7fcacabd83d4270a84baab51ba004169789c",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 無需突變准入 Webhook 注入 I/O 故障"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a9d49f92",
      "source_content": "What about cracking these tough nuts without the mutating admission webhook? Let's get back and think a bit about the reason why we used the mutating admission webhook to add a container in which ChaosFS runs. We do that to mount the filesystem to the target container.",
      "source_content_hash": "f3a6509af0bdb87efaad5c9d255f53bf1cd390dffcbcf964798c6478ad1c2754",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若不使用突變准入 Webhook 該如何解決這些難題？讓我們回溯思考當初為何使用突變准入 Webhook 添加運行 ChaosFS 的容器——是為了將檔案系統掛載至目標容器。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a44047a5",
      "source_content": "In fact, there is another solution. Instead of adding containers to the Pod, we can first use the `setns` Linux system call to modify the namespace of the current process and then use the `mount` call to mount ChaosFS to the target container. Suppose that the filesystem to inject is `/mnt`. The new injection process is as follows:",
      "source_content_hash": "90e836bd809411bd2933339674a4e4a394b777e6e7ee4dbac5d0913bb4eb519e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "事實上另有解法：無需向 Pod 添加容器，我們可先用 `setns` Linux 系統呼叫修改當前行程的命名空間，再透過 `mount` 呼叫將 ChaosFS 掛載至目標容器。假設要注入的檔案系統是 `/mnt`，新注入流程如下："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "11f54993",
      "source_content": "1. Use `setns` for the current process to enter the mnt namespace of the target container.",
      "source_content_hash": "e031b40adc58e1fd4b7961a533fba0d621985090db556e8192d8efaba738551f",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 使用 `setns` 讓當前行程進入目標容器的 mnt 命名空間。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "002560c3",
      "source_content": "2. Execute `mount --move` to move `/mnt` to `/mnt_bak`.",
      "source_content_hash": "eceb11165968556de36034d5c4af378607aaa2e5d5a59eeed32b12f77af3daa6",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 執行 `mount --move` 將 `/mnt` 移動至 `/mnt_bak`。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "0fcf7990",
      "source_content": "3. Mount ChaosFS to `/mnt` and use `/mnt_bak` as the backend.",
      "source_content_hash": "4f0196b305347b14f5edd090fcfe7e59585005a4ead2b080532b62c28290b3e4",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 將 ChaosFS 掛載到 `/mnt` 並使用 `/mnt_bak` 作為後端。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b9aaa519",
      "source_content": "After the process is finished, the target container will open, read, and write the files in `/mnt` through ChaosFS. In this way, delays or faults are injected much more easily. However, there are still two questions to answer:",
      "source_content_hash": "0ba815bdbb0d8e10b74d0096ab0b091b5301e227ce02bca98cc484e4eff361f1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "完成後，目標容器將透過 ChaosFS 開啟、讀取和寫入 `/mnt` 中的檔案，延遲或故障注入因此大幅簡化。但仍有兩個問題待解："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "333176e5",
      "source_content": "- How do you handle the files that are already opened by the target process?",
      "source_content_hash": "bd357d6c63f697b6840f4a19cb62253f8b789aa2ea0e39a41a532cf0d10a65df",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 如何處理目標行程已開啟的檔案？"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2be69f97",
      "source_content": "- How do you recover the process given that we cannot unmount the filesystem when files are opened?",
      "source_content_hash": "053b68d7775df5eb6ee440ecf58448b8c51fd98daad22fbb78825018edb6ca10",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 如何在檔案開啟狀態下（無法卸載檔案系統）恢復行程？"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e912d935",
      "source_content": "### Dynamically replace file descriptors",
      "source_content_hash": "a71fb71db1725bac13adfc0f60d14996e90ec6ab43a97977a40d02afe379db83",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 動態替換檔案描述符"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8b2a52b1",
      "source_content": "**ptrace solves both of the two questions above.** We can use ptrace to replace the opened file descriptors (FD) at runtime and replace the current working directory (CWD) and mmap.",
      "source_content_hash": "36f6cfe3c4c0e305c25816ad5c10ca6a7615e2a9e58a7da00a6f3cec56e719b2",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "**ptrace 可同時解決上述兩個問題**。我們能透過 ptrace 在運行時替換已開啟的檔案描述符 (FD)，並替換當前工作目錄 (CWD) 與 mmap。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "126950d7",
      "source_content": "#### Use ptrace to allow a tracee to run a binary program",
      "source_content_hash": "d734196c2c5eba588562b6d03f3b60b478d1fd76347a14a9066eccfd0775809a",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "#### 使用 ptrace 讓追蹤對象執行二進位程式"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "0bb95128",
      "source_content": "[ptrace](https://man7.org/linux/man-pages/man2/ptrace.2.html) is a powerful tool that makes the target process (tracee) to run any system call or binary program. For a tracee to run the program, ptrace modifies the RIP-pointed address to the target process and adds an `int3` instruction to trigger a breakpoint. When the binary program stops, we need to restore the registers and memory.",
      "source_content_hash": "a4248c2f04cc102745ba18114bdb589afb7c608ad0dcd9bfece1ead5fb186ef3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "[ptrace](https://man7.org/linux/man-pages/man2/ptrace.2.html) 是強大工具，可使目標行程（追蹤對象）執行任意系統呼叫或二進位程式。為讓追蹤對象執行程式，ptrace 會修改 RIP 指向的地址至目標行程，並添加 `int3` 指令觸發中斷點。當二進位程式停止時，需恢復暫存器與記憶體狀態。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c05cce80",
      "source_content": "> **Note:**\n>\n> In the [x86_64 architecture](https://en.wikipedia.org/wiki/X86_assembly_language), the RIP register (also called an instruction pointer) always points to the memory address at which the next directive is run. To load the program into the target process memory spaces:",
      "source_content_hash": "12a3748d34b1d8fd0c2bfff57e5c458ddecc5ecf8f51672a6922682f6dd0769e",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> **注意：**\n>\n> 在 [x86_64 架構](https://en.wikipedia.org/wiki/X86_assembly_language)中，RIP 暫存器（亦稱指令指標）始終指向下個待執行指令的記憶體位址。要將程式載入目標行程記憶體空間："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "4e8535b2",
      "source_content": "1. Use ptrace to call mmap in the target program to allocate the needed memory.",
      "source_content_hash": "4f66f587ccbc118a9d1a972482290f46fe7f316926038f6db11ec274361af561",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 使用 ptrace 呼叫目標程式中的 mmap 來分配所需記憶體。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "032a5911",
      "source_content": "2. Write the binary program to the newly allocated memory and make the RIP register point to it.",
      "source_content_hash": "29ea28f182e937a937cb8860836593c9e110c173c3aad5958d9e9ee0283ff05f",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 將二進位程式寫入新分配的記憶體，並使 RIP 暫存器指向該位置。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ae11e253",
      "source_content": "3. After the binary program stops, call munmap to clean up the memory section.",
      "source_content_hash": "469997964e197d08398c5fa778a9408e9a8ae198d688916ebf6c4461b9ea613a",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 二進位程式停止後，呼叫 munmap 清理記憶體區段。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "afa378f7",
      "source_content": "As a best practice, we often replace ptrace `POKE_TEXT` writes with `process_vm_writev` because if there is a huge amount of data to write, `process_vm_writev` performs more efficiently.",
      "source_content_hash": "f4fae921ec3c804cd739798de2ecf924e7f90806571601413a47b2f252757326",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "最佳實踐是將 ptrace 的 `POKE_TEXT` 寫入替換為 `process_vm_writev`，因為當需寫入大量資料時，`process_vm_writev` 效能更佳。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e8e162a9",
      "source_content": "Using ptrace, we are able to make a process to replace its own FD. Now we only need a method to make that replacement happen. This method is the `dup2` system call.",
      "source_content_hash": "7dac58e74845b099ded87660453f87799ab58180143c3ee3a46feada9e6ce73b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "使用 ptrace，我們能夠讓一個進程替換自身的檔案描述符（FD）。現在我們只需要一種方法來實現這個替換操作，這個方法就是 `dup2` 系統呼叫。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b936dd6a",
      "source_content": "#### Use `dup2` to replace file descriptor",
      "source_content_hash": "666ea60e93034d287e63c5e60ae2f6eb4d0c33a948c916188a3daa58afe75e97",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "#### 使用 `dup2` 替換檔案描述符"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a5c5772a",
      "source_content": "The signature of the `dup2` function is `int dup2(int oldfd, int newfd);`. It is used to create a copy of the old FD (`oldfd`). This copy has an FD number of `newfd`. If `newfd` already corresponds to the FD of an opened file, the FD on the file that's already opened is automatically closed.",
      "source_content_hash": "717eca96316061e89c25f23b7a78e2b246fd21ca3289b1bb5a8ffb79873f0b5e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`dup2` 函數的簽名為 `int dup2(int oldfd, int newfd);`。它用於建立舊 FD (`oldfd`) 的副本，該副本的 FD 編號為 `newfd`。如果 `newfd` 已對應某個已開啟檔案的 FD，系統會自動關閉該已開啟檔案的 FD。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "fbc2db85",
      "source_content": "For example, the current process opens `/var/run/__chaosfs__test__/a` whose FD is `1`. To replace this opened file with `/var/run/test/a`, this process performs the following operations:",
      "source_content_hash": "75cf20205f69ad7bb084465c44e3315f69cbe27e67c7de497fd9344e62d54ad3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "例如，當前進程開啟了 `/var/run/__chaosfs__test__/a`，其 FD 為 `1`。要將此開啟的檔案替換為 `/var/run/test/a`，該進程需執行以下操作："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2c8c6fce",
      "source_content": "1. Uses the `fcntl` system call to get the `OFlags` (the parameter used by the `open` system call, such as `O_WRONLY`) of `/var/run/__chaosfs__test__/a`.",
      "source_content_hash": "79be9ae7a763953c548b5e715211583a149b260e054dc1c724dcab0619b254f0",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "1. 使用 `fcntl` 系統呼叫取得 `/var/run/__chaosfs__test__/a` 的 `OFlags`（即 `open` 系統呼叫的參數，例如 `O_WRONLY`）。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`OFlags`', Translation: '`/var/run/__chaosfs__test__/a`'.",
          "timestamp": "2025-07-04T06:49:59.310858+00:00"
        }
      }
    },
    {
      "segment_id": "e2c83a13",
      "source_content": "2. Uses the `Iseek` system call to get the current location of `seek`.",
      "source_content_hash": "3cdba583f92b203b5a0820a55d8307891f8da59742240a60235157fdb1c71436",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "2. 使用 `lseek` 系統呼叫取得當前 `seek` 位置。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`Iseek`', Translation: '`lseek`'.",
          "timestamp": "2025-07-04T06:49:59.310879+00:00"
        }
      }
    },
    {
      "segment_id": "83fc985d",
      "source_content": "3. Uses the `open` system call to open `/var/run/test/a` using the same `OFlags`. Assume that the FD is `2`.",
      "source_content_hash": "8df88f7bad2193e1274ce73bebd98263db302ba37d4360e92d30410b8b919645",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "3. 使用 `open` 系統呼叫以相同 `OFlags` 開啟 `/var/run/test/a`。假設其 FD 為 `2`。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`/var/run/test/a`', Translation: '`OFlags`'.",
          "timestamp": "2025-07-04T06:49:59.310901+00:00"
        }
      }
    },
    {
      "segment_id": "4ce2fc15",
      "source_content": "4. Uses `Iseek` to change the `seek` location of the newly opened FD `2`.",
      "source_content_hash": "2a399ba9c8084e8e235f19b4fbea7c24e6d49a22b43b6f7cf75fa0407c8a9af6",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "4. 使用 `lseek` 變更新開啟 FD `2` 的 `seek` 位置。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`Iseek`', Translation: '`lseek`'.",
          "timestamp": "2025-07-04T06:49:59.310920+00:00"
        }
      }
    },
    {
      "segment_id": "3cf55645",
      "source_content": "5. Uses `dup2(2, 1)` to replace the FD `1` of `/var/run/__chaosfs__test__/a` with the newly opened FD `2`.",
      "source_content_hash": "6eaa84a92f9ddb39c062c5c901ef013455ad93cd59ffaf7cff580d232ee5a72b",
      "node_type": "listItem",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "5. 使用 `dup2(2, 1)` 將 `/var/run/__chaosfs__test__/a` 的 FD `1` 替換為新開啟的 FD `2`。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`1`', Translation: '`/var/run/__chaosfs__test__/a`'.",
          "timestamp": "2025-07-04T06:49:59.310940+00:00"
        }
      }
    },
    {
      "segment_id": "e5b79bcc",
      "source_content": "6. Closes FD `2`.",
      "source_content_hash": "1e779e1c43f8fa025a9484ef12e7d9ccf1f1c0bf3781bbaecb34896ea4690b25",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "6. 關閉 FD `2`。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6b77b644",
      "source_content": "After the process is finished, FD `1` of the current process points to `/var/run/test/a`. So that we can inject faults, any subsequent operations on the target file go through the [Filesystem in Userspace](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) (FUSE). FUSE is a software interface for Unix and Unix-like computer operating systems that lets non-privileged users create their own file systems without editing kernel code.",
      "source_content_hash": "93d9360074c6fb9eeaa3a3f4533a26cbf6165a322280df9e19a96e52aaa4a97a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "完成後，當前進程的 FD `1` 將指向 `/var/run/test/a`。如此便能注入故障，後續對目標檔案的操作都會經過[用戶空間檔案系統](https://en.wikipedia.org/wiki/Filesystem_in_Userspace)（FUSE）。FUSE 是 Unix 及類 Unix 作業系統的軟體介面，允許非特權使用者無需修改核心程式碼即可建立自有檔案系統。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "5baf88e2",
      "source_content": "#### Write a program to make the target process replace its own file descriptor",
      "source_content_hash": "93ad58ea7eb4b4f3964694134467e8129eea5fca238baa2f35f2d5474eed666a",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "#### 編寫程式使目標進程替換自身檔案描述符"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "eb51d107",
      "source_content": "The combined functionality of ptrace and dup2 makes it possible for the tracer to make the tracee replace the opened FD by itself. Now, we need to write a binary program and make the target process run it:",
      "source_content_hash": "1a5c87a9eaf491ac66f4e1f5e726e3e038980f5c950c07a523c66f9933fac680",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "結合 ptrace 與 dup2 的功能，追蹤程式（tracer）能讓被追蹤程式（tracee）自行替換已開啟的 FD。現在我們需要編寫一個二進位程式，並讓目標進程執行它："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "eff16de8",
      "source_content": "> **Note:**\n>\n> In the implementation above, we assume that:\n>\n> - The threads of the target process are POSIX threads and share the opened files.\n> - When the target process creates threads using the `clone` function, the `CLONE_FILES` parameter is passed.\n>\n> Therefore, Chaos Mesh only replaces the FD of the first thread in the thread group.",
      "source_content_hash": "ddedd89014db31e6b83a00bba741d471b3e5acc172c5bf0e74fef1e4e0f35b46",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> **注意：**\n>\n> 上述實作基於以下假設：\n>\n> - 目標進程的執行緒均為 POSIX 執行緒，且共享已開啟檔案。\n> - 目標進程使用 `clone` 函數建立執行緒時，傳遞了 `CLONE_FILES` 參數。\n>\n> 因此，Chaos Mesh 僅替換執行緒群組中首個執行緒的 FD。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6a21ca8b",
      "source_content": "1. Write a piece of assembly code according to the two sections above and the usage of syscall directives. [Here](https://github.com/chaos-mesh/toda/blob/1d73871d8ab72b8d1eace55f5222b01957193531/src/replacer/fd_replacer.rs#L133) is an example of the assembly code.",
      "source_content_hash": "6263266af1ee59f01c62881eb318c59f65f35cb0bbb67a13588f6854b1a7c77a",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 根據前兩節內容及 syscall 指令用法編寫組語程式碼。[此處](https://github.com/chaos-mesh/toda/blob/1d73871d8ab72b8d1eace55f5222b01957193531/src/replacer/fd_replacer.rs#L133)提供組語程式碼範例。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8c973e92",
      "source_content": "2. Use an assembler to translate the code into a binary program. We use [dynasm-rs](https://github.com/CensoredUsername/dynasm-rs) as the assembler.",
      "source_content_hash": "10e59e79894ccd420e9727d911a4db84d3a074e21fe6d9530d9a7f9475705778",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 使用組譯器將程式碼轉譯為二進位程式。我們採用 [dynasm-rs](https://github.com/CensoredUsername/dynasm-rs) 作為組譯器。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "21429d3b",
      "source_content": "3. Use ptrace to make the target process run this program. When the program runs, the FD is replaced at runtime.",
      "source_content_hash": "510e68fefb603d25b30b17fa2935edbc14cd1e3744389c355aad0d71860a6534",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 透過 ptrace 使目標進程執行此程式。程式執行時，FD 將在運行時被替換。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8574d51c",
      "source_content": "### Overall fault injection process",
      "source_content_hash": "9d9ab86c0e265692d72a9809dac2a8b58f3c9ec8c3f446828b209d136ad400b7",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 整體故障注入流程"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e9313fef",
      "source_content": "The following diagram illustrates the overall I/O fault injection process:",
      "source_content_hash": "22d2c6617fc199001e4048d4e0e979f07e427e7c41f3c3c74edc79f462e5f740",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "下圖展示完整的 I/O 故障注入流程："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1b4de6df",
      "source_content": "![Fault injection process](/img/blog/fault-injection-process.jpg)",
      "source_content_hash": "03d41aa8a6b2d421f0535c0f15ec50061d7d606480de0f3789bf535e140a916c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "![Fault injection process](/img/blog/fault-injection-process.jpg)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1958bc43",
      "source_content": "<div style={{ margin: '1rem 0', fontStyle: 'italic', textAlign: 'center' }}> Fault injection process </div>",
      "source_content_hash": "085e0ce7436f5b66d3def78fd9b9116e51176885144a5838ec68858dd16beb0d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "<div style={{ margin: '1rem 0', fontStyle: 'italic', textAlign: 'center' }}> 故障注入流程 </div>",
          "reason": "Content of a non-translatable 'mdxJsxTextElement' element was changed. Source: '<div style={{ margin: '1rem 0', fontStyle: 'italic', textAlign: 'center' }}> Fault injection process </div>', Translation: '<div style={{ margin: '1rem 0', fontStyle: 'italic', textAlign: 'center' }}> 故障注入流程 </div>'.",
          "timestamp": "2025-07-04T06:49:59.310962+00:00"
        }
      }
    },
    {
      "segment_id": "a8610918",
      "source_content": "In this diagram, each horizontal line corresponds to a thread that runs in the direction of the arrows. The **Mount/Umount Filesystem** and **Replace FD** tasks are carefully arranged in sequence. Given the process above, this arrangement makes a lot of sense.",
      "source_content_hash": "422a8a90283ed5a58d599260395980c9d80fcc022bd403234848dc41809ddc2f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在此圖中，每條水平線對應一個沿箭頭方向運行的執行緒。**掛載/卸載檔案系統**和**替換檔案描述符（FD）**的任務被仔細地按順序排列。鑑於上述過程，這種安排非常合理。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b9b8694c",
      "source_content": "## What's next",
      "source_content_hash": "b90b110a9bc5f59f5e449a7d3c27a1c9cadb64466dc9e6c207bf6764ac41a4a2",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 接下來"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b6152880",
      "source_content": "I've discussed how we implement fault injection to simulate I/O faults at runtime (see [chaos-mesh/toda](https://github.com/chaos-mesh/toda)). However, the current implementation is far from perfect:",
      "source_content_hash": "69ea83c2faa507401158a28af75ab62c595bb7f0e32c8e9199b9a41e4275498f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "我已經討論了我們如何在運行時實作故障注入以模擬 I/O 故障（請參閱 [chaos-mesh/toda](https://github.com/chaos-mesh/toda)）。然而，目前的實作還遠未完美："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "94153371",
      "source_content": "- Generation numbers are not supported.",
      "source_content_hash": "16883f40e7c6480206323c508a132168bd9980a82e3caf973f8fff7280c53843",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 不支援世代編號（generation numbers）"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2acf42db",
      "source_content": "- ioctl is not supported.",
      "source_content_hash": "272cb2473ddaa84c6780bbee1903f011c033816a3701ba21a468ae1037c97172",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 不支援 ioctl 系統呼叫"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7387b539",
      "source_content": "- Chaos Mesh does not immediately determine whether a filesystem is successfully mounted. It does so only after one second.",
      "source_content_hash": "84ade9d0db0d73bb13203a90d86c363203f42dfc6acdbcbb8c451ea6ee9c0f2b",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- Chaos Mesh 不會立即判定檔案系統是否成功掛載，而只會在一秒後才進行判定"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "53aa2b95",
      "source_content": "If you are interested in Chaos Mesh and would like to help us improve it, you're welcome to join [our Slack channel](https://slack.cncf.io/) or submit your pull requests or issues to our [GitHub repository](https://github.com/chaos-mesh/chaos-mesh).",
      "source_content_hash": "714e56c49b8b6eb85a7a57dd7857bfdbb4d077c57eda31bcf9b4233c0890c10f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "如果您對 Chaos Mesh 感興趣並希望協助我們改進，歡迎加入 [我們的 Slack 頻道](https://slack.cncf.io/) 或提交拉取請求（pull requests）及問題至我們的 [GitHub 儲存庫](https://github.com/chaos-mesh/chaos-mesh)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9c9e2b64",
      "source_content": "This is the first post in a series on Chaos Mesh implementation. If you want to see how other types of fault injection are implemented, stay tuned.",
      "source_content_hash": "92068ad6b311afc3a6edf10359a1cb331ce6fb73257ff4779ca8717f9bf29b76",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "這是 Chaos Mesh 實作系列文章的第一篇。若您想了解其他類型的故障注入如何實作，請持續關注。"
      },
      "invalid_translations": {}
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-blog/2021-01-08-how-to-simulate-io-faults-at-runtime.md",
  "last_updated_timestamp": "2025-07-04T06:49:59.310994+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "80c42f9c79bb41d54431409e6bc9fe5ddc624a729fc0765b6294d61f88c64a1f"
  }
}