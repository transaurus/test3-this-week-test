{
  "source_file_path_relative_to_docusaurus_root": "versioned_docs/version-2.7.2/simulate-http-chaos-on-kubernetes.md",
  "source_file_content_hash": "73824c2a8f1427431595ccd20f7b4f92f58b796c1a502305d97a8dedd5e6bdb3",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\ntitle: Simulate HTTP Faults\n---",
      "source_content_hash": "d4c1566308ad0b326936fe968a3e55e1a26dd0ae27e34e0bfab3c81a4eda9e3a",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_58cfcc64"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e7ec8f99",
      "source_content": "This document describes how to simulate HTTP faults by creating HTTPChaos experiments in Chaos Mesh.",
      "source_content_hash": "84e78b5e4112dd6c1e0a86f5396ec722d0d61bad1918c250c409dc429b286593",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "本文件說明如何透過在 Chaos Mesh 中建立 HTTPChaos 實驗來模擬 HTTP 故障。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "a703643c",
      "source_content": "## HTTPChaos introduction",
      "source_content_hash": "8ca2e4043efee463ed7d3e320c18273a5b2deb6cf5410f292bd731f20a3bdd3b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## HTTPChaos 介紹"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "53eaf0e1",
      "source_content": "HTTPChaos is a fault type provided by Chaos Mesh. By creating HTTPChaos experiments, you can simulate the fault scenarios during the HTTP request and response processing. Currently, HTTPChaos supports simulating the following fault types:",
      "source_content_hash": "e5f84bfe106c7dace117606a827849d3f9315de07016dbdcb27d27e3c3b34602",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "HTTPChaos 是 Chaos Mesh 提供的故障類型。透過建立 HTTPChaos 實驗，您可以模擬 HTTP 請求和響應處理過程中的故障場景。目前 HTTPChaos 支援模擬以下故障類型："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "760d111a",
      "source_content": "- `abort`: interrupts the connection",
      "source_content_hash": "b55c98a797d7f7540ac299c8909e0f415c9992299bcd030b83bc994873876828",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- `abort`：中斷連線"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1ee0c6cb",
      "source_content": "- `delay`: injects latency into the request or response",
      "source_content_hash": "bff211d5b6e17c3b6af8cfb0466bafff90cd3d546013d9d2129272d31865c410",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- `delay`：在請求或響應中注入延遲"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2b4a9900",
      "source_content": "- `replace`: replaces part of content in HTTP request or response messages",
      "source_content_hash": "0e785fae47885c30f516241062f3b39391e2f4593effd5bf04cc6ad2fb57bb7c",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- `replace`：替換 HTTP 請求或響應訊息中的部分內容"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9a03a62b",
      "source_content": "- `patch`: adds additional content to HTTP request or response messages",
      "source_content_hash": "f59a4959b2721553f312ac60e762180982c283c851dee8275d2709a0cf79b43c",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- `patch`：在 HTTP 請求或響應訊息中添加額外內容"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "86b54d44",
      "source_content": "HTTPChaos supports combinations of different fault types. If you have configured multiple HTTP fault types at the same time when creating HTTPChaos experiments, the order set to inject the faults when the experiments start running is `abort` -> `delay` -> `replace` -> `patch`. When the `abort` fault cause short circuits, the connection will be directly interrupted.",
      "source_content_hash": "ece0a43cde7d077b0206666b252f8dde7693cd0fcacc94a7e7683c374d6facf7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "HTTPChaos 支援不同故障類型的組合。若在建立 HTTPChaos 實驗時同時配置多個 HTTP 故障類型，實驗運行時注入故障的順序為 `abort` -> `delay` -> `replace` -> `patch`。當 `abort` 故障導致短路時，連線將直接中斷。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "39b3772c",
      "source_content": "For the detailed description of HTTPChaos configuration, see [Field description](#field-description) below.",
      "source_content_hash": "62160e8f9657cd3bf2785f18910c07e724a68848f95b8f7c2e34eee660cf890f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "有關 HTTPChaos 配置的詳細說明，請參閱下方的[欄位說明](#field-description)。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "bc633244",
      "source_content": "## Notes",
      "source_content_hash": "63e13e87b378d1e85f838ead267db9020c1457b1118a37e0af9fb5f976144f4b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 注意事項"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "2df4f75f",
      "source_content": "Before injecting the faults supported by HTTPChaos, note the followings:",
      "source_content_hash": "9385dae3e722cf035c8b7304f6d6ebe61c69ef94fe9d0d7be696ad6062ae7bab",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在注入 HTTPChaos 支援的故障前，請注意以下事項："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d7f0c63d",
      "source_content": "- There is no control manager of Chaos Mesh running on the target Pod.",
      "source_content_hash": "00334dd7ac438e7530a4d885bf8786ac4c6ca4aebd159112e771e33d5c702f59",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 目標 Pod 上沒有運行 Chaos Mesh 的控制管理器。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ff75e5d8",
      "source_content": "- The rules will affect both of clients and servers in the Pod, if you want to affect only one side, please refer to the [specify side](#specify-side) section.",
      "source_content_hash": "c677d5d52a0887465b1b965379b7349a8d8ac870de80c14e46946f1c8c3e9b62",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 規則預設會影響 Pod 中的客戶端和伺服器端，若需僅影響單側，請參閱[指定側](#specify-side)章節。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cec935ef",
      "source_content": "- HTTPS accesses should be disabled, because injecting HTTPS connections is not supported currently.",
      "source_content_hash": "fd452563bd8ba38e1181160fefe0021cfb22ae5e5d307e17ec91a4a53bd40191",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 應禁用 HTTPS 訪問，因為目前不支援注入 HTTPS 連線。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b08b37ac",
      "source_content": "- For HTTPChaos injection to take effect, the client should avoid reusing TCP socket. This is because HTTPChaos does not affect the HTTP requests that are sent via TCP socket before the fault injection.",
      "source_content_hash": "c7803febb1ac2af150cd3c6400a690117406d070c721e3e4781ad323861e6870",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 為使 HTTPChaos 注入生效，客戶端應避免重複使用 TCP 通訊端。這是因為 HTTPChaos 不會影響故障注入前透過 TCP 通訊端發送的 HTTP 請求。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "882f8186",
      "source_content": "- Use non-idempotent requests (such as most of the POST requests) with caution in production environments. If such requests are used, the target service may not return to normal status by repeating requests after the fault injection.",
      "source_content_hash": "306d395289b1ecefd6b523d02d462de9a37d31c6803901e523406e8e9c9b5d75",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "- 在生產環境中謹慎使用非冪等請求（例如大多數 POST 請求）。若使用此類請求，故障注入後目標服務可能無法透過重複請求恢復正常狀態。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d06306f7",
      "source_content": "## Create experiments using Chaos Dashboard",
      "source_content_hash": "0e6c13931d3c46c241532f93bf2c43261695607133973a006c15d6651045ed71",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 使用 Chaos Dashboard 建立實驗"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "56d666fe",
      "source_content": "1. Open Chaos Dashboard, and click **NEW EXPERIMENT** on the page to create a new experiment:\n\n   ![create an experiment](./img/create-new-exp.png)",
      "source_content_hash": "2d17f7a8b0e73ed2486b1d73efdf61381481a451f29995e27edb5c71dfa051c7",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 開啟 Chaos Dashboard，點擊頁面上的**新建實驗**建立新實驗：\n\n   ![create an experiment](./img/create-new-exp.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cc5346ac",
      "source_content": "2. In the **Choose a Target** area, choose **HTTP FAULT** and select a specific behavior, such as `RESPONSE ABORT`. Then fill out specific configurations.\n\n   ![create HTTP fault](./img/create-new-httpchaos.png)",
      "source_content_hash": "d3f60923cc4eff73d11672a8e27400c1f86fb64240c1a5a8e870bc9bb01f8ce1",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 在**選擇目標**區域，選擇 **HTTP 故障**並選取特定行為（例如 `RESPONSE ABORT`），然後填寫具體配置。\n\n   ![create HTTP fault](./img/create-new-httpchaos.png)"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "4a0e7cce",
      "source_content": "3. Submit the experiment.\n\n   In the example above, you have configured injecting the \"Response abort\" fault into all requests of Port 80.",
      "source_content_hash": "d2cf58f71823c79d827e4ff6130aec26f177c673ea1d6836430e8a0f3e99b297",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 提交實驗。\n\n   在上述範例中，您已配置將「響應中止」故障注入 Port 80 的所有請求。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "54268405",
      "source_content": "## Create experiments using YAML files",
      "source_content_hash": "87be3d29972bae4243b6969851f9d8cee6ef367c0b93cb5fe2ad6e4c107cd5a3",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 使用 YAML 檔案建立實驗"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8af76f3d",
      "source_content": "Chaos Mesh also supports using YAML configuration files to create HTTPChaos experiments. In a YAML file, you can simulate either one HTTP fault type or a combination of different HTTP fault types.",
      "source_content_hash": "f1cf8611d73520cba49cc62263598bcd2e6d1407284593387c8973f4ad9afad0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Chaos Mesh 也支援使用 YAML 配置檔案建立 HTTPChaos 實驗。在 YAML 檔案中，您可以模擬單一 HTTP 故障類型或多種 HTTP 故障類型的組合。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c674e260",
      "source_content": "### Example of `abort`",
      "source_content_hash": "a21805bc0faa5df54ce8245a3c1b917d6f41be85af2511fd690ab828c4c1bde1",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### `abort` 範例"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "b1573599",
      "source_content": "1. Write the experimental configuration to the `http-abort-failure.yaml` file as the example below:\n\n   ```yaml\n   apiVersion: chaos-mesh.org/v1alpha1\n   kind: HTTPChaos\n   metadata:\n     name: test-http-chaos\n   spec:\n     mode: all\n     selector:\n       labelSelectors:\n         app: nginx\n     target: Request\n     port: 80\n     method: GET\n     path: /api\n     abort: true\n     duration: 5m\n   ```\n\n   Based on this configuration example, Chaos Mesh will inject the `abort` fault into the specified pod for 5 minutes. During the fault injection, the GET requests sent through port 80 in the `/api` path of the target Pod will be interrupted.",
      "source_content_hash": "8a98be939d9cd0d99728c4fc4ea32343322b530dc4d1c5384426a944ed442bfd",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 將實驗配置寫入 `http-abort-failure.yaml` 檔案，範例如下：\n\n   ```yaml\n   apiVersion: chaos-mesh.org/v1alpha1\n   kind: HTTPChaos\n   metadata:\n     name: test-http-chaos\n   spec:\n     mode: all\n     selector:\n       labelSelectors:\n         app: nginx\n     target: Request\n     port: 80\n     method: GET\n     path: /api\n     abort: true\n     duration: 5m\n   ```\n\n   根據此配置範例，Chaos Mesh 將在 5 分鐘內向指定 Pod 注入 `abort` 故障。故障注入期間，目標 Pod 在 `/api` 路徑透過 Port 80 發送的 GET 請求將被中斷。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3ed00714",
      "source_content": "2. After the configuration file is prepared, use `kubectl` to create the experiment:\n\n   ```bash\n   kubectl apply -f ./http-abort-failure.yaml\n   ```",
      "source_content_hash": "e9c88c03887e514a2fd93614838029db55f8ab1ffc4eed7eebb8b9bda6bf28a4",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 準備好配置檔案後，使用 `kubectl` 建立實驗：\n\n   ```bash\n   kubectl apply -f ./http-abort-failure.yaml\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "98355e36",
      "source_content": "### Example of fault combinations",
      "source_content_hash": "b8283c40ca762ab9aef065e5ebe802ae180510877c2ebc1bb8ab33a48e87fcbe",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 故障組合範例"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "dff3cae1",
      "source_content": "1. Write the experimental configuration to `http-failure.yaml` file as the example below:\n\n   ```yaml\n   apiVersion: chaos-mesh.org/v1alpha1\n   kind: HTTPChaos\n   metadata:\n     name: test-http-chaos\n   spec:\n     mode: all\n     selector:\n       labelSelectors:\n         app: nginx\n     target: Request\n     port: 80\n     method: GET\n     path: /api/*\n     delay: 10s\n     replace:\n       path: /api/v2/\n       method: DELETE\n     patch:\n       headers:\n         - ['Token', '<one token>']\n         - ['Token', '<another token>']\n       body:\n         type: JSON\n         value: '{\"foo\": \"bar\"}'\n     duration: 5m\n   ```\n\n   Based on this configuration example, Chaos Mesh will inject the `delay` fault, `replace` fault, and `patch` fault consecutively.",
      "source_content_hash": "3a4302e52e6d28c01c6fdc4a5344951af74a52deb14b7e45dbd4fc3187ad2319",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 將實驗配置寫入 `http-failure.yaml` 檔案，如下例所示：\n\n   ```yaml\n   apiVersion: chaos-mesh.org/v1alpha1\n   kind: HTTPChaos\n   metadata:\n     name: test-http-chaos\n   spec:\n     mode: all\n     selector:\n       labelSelectors:\n         app: nginx\n     target: Request\n     port: 80\n     method: GET\n     path: /api/*\n     delay: 10s\n     replace:\n       path: /api/v2/\n       method: DELETE\n     patch:\n       headers:\n         - ['Token', '<one token>']\n         - ['Token', '<another token>']\n       body:\n         type: JSON\n         value: '{\"foo\": \"bar\"}'\n     duration: 5m\n   ```\n\n   根據此配置範例，Chaos Mesh 將連續注入 `delay` 故障、`replace` 故障和 `patch` 故障。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6555a208",
      "source_content": "2. After the configuration file is prepared, use `kubectl` to create the experiment:\n\n   ```bash\n   kubectl apply -f ./http-failure.yaml\n   ```",
      "source_content_hash": "73fab301300c480eecd00c853fb08d66a9ce0d841725a1f7a43cd7cd7f7e06dd",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 準備好配置檔案後，使用 `kubectl` 建立實驗：\n\n   ```bash\n   kubectl apply -f ./http-failure.yaml\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f8614e13",
      "source_content": "## Field description",
      "source_content_hash": "afef87832591f63e7a3c9579f8a2492cf81afc3e8b0d02296e334646ad82d4f6",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 欄位描述"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "638efb88",
      "source_content": "### Description for common fields",
      "source_content_hash": "b031f67524fea55d284837249320870c0901ab5ba99c0f8d6c5e972db29428af",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 通用欄位描述"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "558df877",
      "source_content": "Common fields are meaningful when the `target` of fault injection is `Request` or `Response`.",
      "source_content_hash": "c31f719ab8ecc97719500c40b157db6a5ee2c3907ef8df39c111277b346ccc45",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "當故障注入的 `target` 為 `Request` 或 `Response` 時，通用欄位才具有意義。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "aaf39b16",
      "source_content": "| Parameter | Type | Description | Default value | Required | Example |\n| --- | --- | --- | --- | --- | --- |\n| `mode` | string | Specifies the mode of the experiment. The mode options include `one` (selecting a random pod), `all` (selecting all eligible pods), `fixed` (selecting a specified number of eligible pods), `fixed-percent` (selecting a specified percentage of Pods from the eligible pods), and `random-max-percent` (selecting the maximum percentage of Pods from the eligible pods). |  | yes | `one` |\n| `value` | string | Provides parameters for the `mode` configuration depending on the value of `mode`. |  | no | 1 |\n| `target` | string | Specifies whether the target of fault injuection is `Request` or `Response`. The [`target`-related fields](#description-for-target-related-fields) should be configured at the same time. |  | yes | Request |\n| `port` | int32 | The TCP port that the target service listens on. |  | yes | 80 |\n| `path` | string | The URI path of the target request. Supports [Matching wildcards](https://www.wikiwand.com/en/Matching_wildcards). | Takes effect on all paths by default. | no | /api/\\* |\n| `method` | string | The HTTP method of the target request method. | Takes effect for all methods by default. | no | GET |\n| `request_headers` | map[string]string | Matches request headers to the target service. | Takes effect for all requests by default. | no | Content-Type: application/json |\n| `abort` | bool | Indicates whether to inject the fault that interrupts the connection. | false | no | true |\n| `delay` | string | Specifies the time for a latency fault. | 0 | no | 10s |\n| `replace.headers` | map[string]string | Specifies the key pair used to replace the request headers or response headers. |  | no | Content-Type: application/xml |\n| `replace.body` | []byte | Specifies request body or response body to replace the fault (Base64 encoded). |  | no | eyJmb28iOiAiYmFyIn0K |\n| `patch.headers` | [][]string | Specifies the attached key pair of the request headers or response headers with patch faults. |  | no | - [Set-Cookie, one cookie] |\n| `patch.body.type` | string | Specifies the type of patch faults of the request body or response body. Currently, it only supports [`JSON`](https://tools.ietf.org/html/rfc7396). |  | no | JSON |\n| `patch.body.value` | string | Specifies the fault of the request body or response body with patch faults. |  | no | `{\"foo\": \"bar\"}` |\n| `duration` | string | Specifies the duration of a specific experiment. |  | yes | 30s |\n| `scheduler` | string | Specifies the scheduling rules for the time of a specific experiment. |  | no | 5 \\* \\* \\* \\* |\n| `tls.secretName` | string | SecretName represents the name of required secret resource. The secrete must combined with data `{\"tls.certName\":cert, \"tls.KeyName\":key, \"tls.caName\":ca}` |  | no | \"http-tls-scr\" |\n| `tls.secretNamespace` | string | SecretNamespace represents the namespace of required secret resource,should be the same with deployment/chaos-controller-manager in most cases |  | no | \"chaos-mesh\" |\n| `tls.certName` | string | CertName represents the data name of cert file in secret, `tls.crt` for example |  | no | \"tls.crt\" |\n| `tls.KeyName` | string | KeyName represents the data name of key file in secret, `tls.key` for example |  | no | \"tls.key\" |\n| `tls.caName` | string | CAName represents the data name of ca file in secret, `ca.crt` for example |  | no | \"ca.crt\" |",
      "source_content_hash": "e5a618884001bbb634199cb344900cc88158aeb6bcbf0b038ea1eb331987be3e",
      "node_type": "table",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_aaf39b16"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "fd42cd42",
      "source_content": ":::note\n\n- When creating experiments with YAML files, `replace.body` must be the base64 encoding of the replacement content.\n\n- When creating experiments with the Kubernetes API, there is no need to encode the replacement content, just convert it to `[]byte` and put it into the `httpchaos.Spec.Replace.Body` field. The following is an example:\n\n```golang\nhttpchaos.Spec.Replace.Body = []byte(`{\"foo\": \"bar\"}`)\n```\n\n:::",
      "source_content_hash": "38acb693bee688aa4e11da3b0d8c7126a3547beb01501064192aa3bc9dda87c6",
      "node_type": "containerDirective",
      "translatable": true,
      "translations": {
        "zh-hant": ":::note\n\n- 使用 YAML 檔案建立實驗時，`replace.body` 必須是替換內容的 base64 編碼。\n- 使用 Kubernetes API 建立實驗時，不需要對替換內容進行編碼，只需將其轉換為 `[]byte` 並放入 `httpchaos.Spec.Replace.Body` 欄位。以下為範例：\n\n```golang\nhttpchaos.Spec.Replace.Body = []byte(`{\"foo\": \"bar\"}`)\n```\n\n:::"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "531ec0bb",
      "source_content": "### Description for `target`-related fields",
      "source_content_hash": "f0bf89a583320ed536b7f485b3b896ea541a1309c9f909be9854f76958a06132",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### `target` 相關欄位描述"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ee213c98",
      "source_content": "#### `Request`-related fields",
      "source_content_hash": "7db989a7647ffb8a8ac8679476fe1662aa77d3b0bd52637a7fd6fb6139af0178",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "#### `Request` 相關欄位"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "008183b0",
      "source_content": "The `Request` field is a meaningful when the `target` set to `Request` during the fault injection.",
      "source_content_hash": "03dd48bc27d1bdb1e43a63e48ad00927b1fddf081bcfec5b4a738a9294f4cbe7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "當故障注入期間 `target` 設定為 `Request` 時，`Request` 欄位才具有意義。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`Request`', Translation: '`target`'.",
          "timestamp": "2025-07-04T06:49:59.321949+00:00"
        }
      }
    },
    {
      "segment_id": "affefa6f",
      "source_content": "| Parameter | Type | Description | Default value | Required | Example |\n| --- | --- | --- | --- | --- | --- |\n| `replace.path` | string | Specifies the URI path used to replace content. |  | no | /api/v2/ |\n| `replace.method` | string | Specifies the replaced content of the HTTP request method. |  | no | DELETE |\n| `replace.queries` | map[string]string | Specifies the replaced key pair of the URI query. |  | no | foo: bar |\n| `patch.queries` | [][]string | Specifies the attached key pair of the URI query with patch faults. |  | no | - [foo, bar] |",
      "source_content_hash": "bb9ff0fa74f1f4b124197dd124054e028bf0e7073ed6103c47319907fcfad86f",
      "node_type": "table",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_affefa6f"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6ffd1ebe",
      "source_content": "#### `Respond`-related fields",
      "source_content_hash": "5252d82f07c60957dd816c474f13ff070eb1b5ca4eeab9b0e7c8d2baffcee13b",
      "node_type": "heading",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "#### `Response` 相關欄位",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`Respond`', Translation: '`Response`'.",
          "timestamp": "2025-07-04T06:49:59.321979+00:00"
        }
      }
    },
    {
      "segment_id": "89cf7bac",
      "source_content": "The `Response` is a meaningful when the `target` set to `Response` during the fault injection.",
      "source_content_hash": "bc77bb904e2a79699c35cdb77960f465ecb1953067b9378aeb036214de26dc6b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {},
      "invalid_translations": {
        "zh-hant": {
          "translation": "當故障注入期間 `target` 設定為 `Response` 時，`Response` 欄位才具有意義。",
          "reason": "Content of a non-translatable 'inlineCode' element was changed. Source: '`Response`', Translation: '`target`'.",
          "timestamp": "2025-07-04T06:49:59.322004+00:00"
        }
      }
    },
    {
      "segment_id": "41321865",
      "source_content": "| Parameter | Type | Description | Default value | Required | Example |\n| --- | --- | --- | --- | --- | --- |\n| `code` | int32 | Specifies the status code responded by `target`. | Takes effect for all status codes by default. | no | 200 |\n| `response_headers` | map[string]string | Matches request headers to `target`. | Takes effect for all responses by default. | no | Content-Type: application/json |\n| `replace.code` | int32 | Specifies the replaced content of the response status code. |  | no | 404 |",
      "source_content_hash": "179de6d4277f005f39dfca47ab2d9801713cb35b7d49f542677827a3f825c9c7",
      "node_type": "table",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_41321865"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "8d279c43",
      "source_content": "## Specify side",
      "source_content_hash": "373116e89fde9ded1ad804d7966e824994073cae65ae674ef981802fd5ac1f80",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 指定端"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "e5821418",
      "source_content": "The rules will affect both of clients and servers in the Pod by default, but you can affect only one side by selecting the request headers.",
      "source_content_hash": "29d818e23f814ed962de51b82b209b69a217a37efa6361577f4d32800e4e97e8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "預設情況下，規則將同時影響 Pod 中的客戶端和伺服器端，但您可以透過選擇請求標頭來僅影響其中一端。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "4e2e17c5",
      "source_content": "This section provides some examples to specify the affected side, you can adjust the header selector in rules depend on your particular cases.",
      "source_content_hash": "0516c780d889d3f9bedc9c9398b5ad3b9ad6ff123f52fa44dbe5519804306945",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "本節提供一些指定受影響端的範例，您可以根據具體情況調整規則中的標頭選擇器。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "cce332f2",
      "source_content": "### Client side",
      "source_content_hash": "546a189f37023ac0df35d95a1c5964430af66ac9c0640ae55824fd6188482d77",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 客戶端"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "9ebd9d9b",
      "source_content": "To inject faults into clients in the Pod without affecting servers, you can select the request/response by the `Host` header in the request.",
      "source_content_hash": "755fa2a4f98236f46c9300c4f7c2537f5088f7fa59dbba4344b4b4abf03a8b21",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若要將故障注入 Pod 中的客戶端而不影響伺服器端，您可以透過請求中的 `Host` 標頭來選擇請求/回應。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "295367fa",
      "source_content": "For example, if you want to interrupt all requests to `http://example.com/`, you can apply the following YAML config:",
      "source_content_hash": "08ec6360e5c6321720de8e87c8fc355d817530f202ceee3ac313abf5f59e5fc0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "例如，如果您想中斷對 `http://example.com/` 的所有請求，可以套用以下 YAML 配置："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "edfcc73c",
      "source_content": "```yaml\napiVersion: chaos-mesh.org/v1alpha1\nkind: HTTPChaos\nmetadata:\n  name: test-http-client\nspec:\n  mode: all\n  selector:\n    labelSelectors:\n      app: some-http-client\n  target: Request\n  port: 80\n  path: '*'\n  request_headers:\n    Host: 'example.com'\n  abort: true\n```",
      "source_content_hash": "a3bd44529f336815fbf9c2df4d7df34059a66ca38b4ef88bb69adb09f72dc473",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_edfcc73c"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "97496aad",
      "source_content": "### Server side",
      "source_content_hash": "809618560f5b394a0e2b4a5e9ce4cc3394388988103abea4ce41078cb3cc4975",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 伺服器端"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "af834e0d",
      "source_content": "To inject faults into servers in the Pod without affecting clients, you can also select the request/response by the `Host` header in the request.",
      "source_content_hash": "04d4a7c645c40cb50f4fa9c4a3670263133e12b50fc37c0c3b987ccc2d88d4d7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若要將故障注入 Pod 中的伺服器端而不影響客戶端，您也可以透過請求中的 `Host` 標頭來選擇請求/回應。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d75361e3",
      "source_content": "For example, if you want to interrupt all requests to your server behind service `nginx.nginx.svc`, you can apply the following YAML config:",
      "source_content_hash": "42e2fe10ef36bb896a3e5125fa3c6000f0b5add3de60c45d5583465a2b6b8640",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "例如，如果您想中斷對服務 `nginx.nginx.svc` 後端伺服器的所有請求，可以套用以下 YAML 配置："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "3ae81768",
      "source_content": "```yaml\napiVersion: chaos-mesh.org/v1alpha1\nkind: HTTPChaos\nmetadata:\n  name: test-http-server\nspec:\n  mode: all\n  selector:\n    labelSelectors:\n      app: nginx\n  target: Request\n  port: 80\n  path: '*'\n  request_headers:\n    Host: 'nginx.nginx.svc'\n  abort: true\n```",
      "source_content_hash": "1433e7774cf6024aeac94e4b4c0c4aef960cd104ff0c215eb45083b19089b689",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_3ae81768"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "130a77cc",
      "source_content": "In other cases, especially when injecting the inbound request from outside, you may select the request/response by the `X-Forwarded-Host` header in the request.",
      "source_content_hash": "1d746102617f127d63227e989e221d93f02f02c855e2b597a95e7d669f3068d6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在其他情況下，特別是當注入來自外部的入站請求時，您可以透過請求中的 `X-Forwarded-Host` 標頭來選擇請求/回應。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "d119b75c",
      "source_content": "For example, if you want to interrupt all requests to your server behind a public gateway `nginx.host.org`, you can apply the following YAML config:",
      "source_content_hash": "8d914ed1c5a326917f43f4dc25776ac56586a6a173720eacbcb62254b98d6cbd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "例如，如果您想中斷對公共網關 `nginx.host.org` 後端伺服器的所有請求，可以套用以下 YAML 配置："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "bce471ae",
      "source_content": "```yaml\napiVersion: chaos-mesh.org/v1alpha1\nkind: HTTPChaos\nmetadata:\n  name: test-http-server\nspec:\n  mode: all\n  selector:\n    labelSelectors:\n      app: nginx\n  target: Request\n  port: 80\n  path: '*'\n  request_headers:\n    X-Forwarded-Host: 'nginx.host.org'\n  abort: true\n```",
      "source_content_hash": "fc61ec80792c12333f769d0aab006d3c907ce3ee1ce7ee2e54d7087d4d59c32f",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_bce471ae"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "371cb514",
      "source_content": "## TLS",
      "source_content_hash": "991c43119fd2e3440124ae0f94ddc5cd69db8e1fbe09e7d4305caa3bb11f422f",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## TLS"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "5d5a3416",
      "source_content": "To inject faults inside connection base on TLS, user should use TLS mode. Our proxy play a proxy role here, so in TLS people both need to act as a remote server with a trustful CA , but also need to act as a client trust the server with some ca.",
      "source_content_hash": "0c9345b37c7545fcbf89d599538a3737fe6a638a6b6e4e9b371ae35c8f526856",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若要基於 TLS 在連線內部注入故障，使用者應使用 TLS 模式。我們的代理在此扮演代理角色，因此在 TLS 中，人們既需要充當具有可信 CA 的遠端伺服器，也需要充當信任該伺服器的客戶端（使用一些 CA）。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "070ff7a2",
      "source_content": "So in the secret data blow user need to create its' TLS keys & CA & CRT on their own.",
      "source_content_hash": "2ecea5bb56d465fe1e6ebeb963b0a59420a478987132fe0c4605a81eea3cc245",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "因此在以下的密鑰資料中，使用者需要自行建立其 TLS 金鑰、CA 及 CRT。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "703442ed",
      "source_content": "```\n{\n  \"tls.certName\":cert,\n  \"tls.KeyName\":key,\n  \"tls.caName\":ca\n}\n```",
      "source_content_hash": "0f0ad130c2f640be83955e0003ca76538425193ee560d9d5a949a95d5b276c90",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_703442ed"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "f4b938fe",
      "source_content": "If user need to create a new TLS server and inject the connection to it, they should:",
      "source_content_hash": "311f0e2c81740ea60942ed46021a84e2284942780f337b5815a4dd98f9f8f23e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若使用者需要建立新的 TLS 伺服器並將連線注入其中，則應執行下列步驟："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "6296b9e4",
      "source_content": "1. Create their own root CA's private key and root CA's certificate:\n\n   ```\n   openssl req -newkey rsa:4096  -x509  -sha512  -days 365 -nodes -out ca.crt -keyout ca.key\n   ```",
      "source_content_hash": "e0dd7f14abb27915981f81634ee8316df4c78249d24d93ffa252ea5afb84a591",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "1. 建立自己的根 CA 私鑰及根 CA 憑證：\n\n   ```\n   openssl req -newkey rsa:4096  -x509  -sha512  -days 365 -nodes -out ca.crt -keyout ca.key\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "33854bf3",
      "source_content": "2. Create their server's Certificate Signing Request:\n\n   ```\n   openssl genrsa -out server.key 2048\n   openssl req -new -key server.key -out server.csr\n   ```",
      "source_content_hash": "f8a5534cdc249ceba14531c5db4204bfb07352db58ebe9e92e557d29208879fa",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "2. 建立伺服器的憑證簽署要求 (CSR)：\n\n   ```\n   openssl genrsa -out server.key 2048\n   openssl req -new -key server.key -out server.csr\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "23aca5fb",
      "source_content": "3. Write an extension file `server.ext` for the server like:\n\n   ```\n   authorityKeyIdentifier=keyid,issuer\n   basicConstraints=CA:FALSE\n   keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\n   subjectAltName = @alt_names\n\n   [alt_names]\n   IP.1 = X.X.X.X\n   ```",
      "source_content_hash": "ab7e7d6e9f0d355e05bba5abc2759c5b2e1c33758ba8697608b33e447ebf0786",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "3. 為伺服器撰寫擴充檔案 `server.ext`，內容範例如下：\n\n   ```\n   authorityKeyIdentifier=keyid,issuer\n   basicConstraints=CA:FALSE\n   keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\n   subjectAltName = @alt_names\n\n   [alt_names]\n   IP.1 = X.X.X.X\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "7356c3df",
      "source_content": "4. Generate certificate of server:\n\n   ```\n   openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365 -sha256 -extfile server.ext\n   ```",
      "source_content_hash": "518e829a1810eb0bc14d49b27b76a0ce446b55242584d0389359bef15b832aad",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "4. 產生伺服器憑證：\n\n   ```\n   openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365 -sha256 -extfile server.ext\n   ```"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "0fb10be0",
      "source_content": "5. Add CA `ca.crt` to client.",
      "source_content_hash": "2ee5d9e2f0503f21275a479b0803a0f278fe729a125876b940e7835fc12705d7",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "5. 將 CA `ca.crt` 加入用戶端。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "c3ddf07b",
      "source_content": "6. Put `server.key`, `server.crt`, `ca.crt` into a secrete and give it to TLS mode.",
      "source_content_hash": "a2bb069d733f3d6b566c0907250e49d3a8040ab2d45846abd727bbbe6c430600",
      "node_type": "listItem",
      "translatable": true,
      "translations": {
        "zh-hant": "6. 將 `server.key`、`server.crt` 及 `ca.crt` 放入密鑰 (secret) 中，並提供給 TLS 模式。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "95b3e282",
      "source_content": "If user need to inject a client , they should act the proxy of HTTP Chaos like the remote server , you should just edit `server.ext` above to the specify domain.",
      "source_content_hash": "faa9e1afacb7d6635b40e121037ae5ec11c677ff18de983e842e39c8fa3a4c42",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若需要注入用戶端，則應讓 HTTP Chaos 的代理扮演遠端伺服器，只需將上述的 `server.ext` 編輯為指定的網域即可。"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "1f92e934",
      "source_content": "Example:",
      "source_content_hash": "872887e563e75957ffc20b021332504f2ddd0a8f3964cb93070863bfaf13cdad",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "範例："
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "bdb6a28d",
      "source_content": "```\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = *.domain.com\nIP.1 = xxx.xxx.xxx.xxx\n```",
      "source_content_hash": "4b7da1182011ed28ea1adfd835c2938782dfb9310e9b2e2667a334455a896a7c",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_bdb6a28d"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "363f5ed5",
      "source_content": "## Local debugging",
      "source_content_hash": "abedfa9d762e5b2b5c56723048fd359f88bdcefb74790dee728d57a72e3e8dd9",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 本地除錯"
      },
      "invalid_translations": {}
    },
    {
      "segment_id": "ebe673d6",
      "source_content": "If you are not sure of the effects of certain fault injections, you can also test the corresponding features locally using [rs-tproxy](https://github.com/chaos-mesh/rs-tproxy). Chaos Mesh also provides HTTP Chaos by using chaos-tproxy.",
      "source_content_hash": "ec79127cb8cba75c541465cf4a6c29e7895b087e89ce7c3ee803cbb3d3685c06",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "若不確定某些故障注入的效果，您也可以使用 [rs-tproxy](https://github.com/chaos-mesh/rs-tproxy) 在本機測試對應功能。Chaos Mesh 也透過 chaos-tproxy 提供 HTTP Chaos。"
      },
      "invalid_translations": {}
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-docs/version-2.7.2/simulate-http-chaos-on-kubernetes.md",
  "last_updated_timestamp": "2025-07-04T06:49:59.322035+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "73824c2a8f1427431595ccd20f7b4f92f58b796c1a502305d97a8dedd5e6bdb3"
  }
}